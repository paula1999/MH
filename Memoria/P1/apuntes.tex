\section{Descripción o formulación del problema}
	Esta práctica consiste en encontrar una solución al \textbf{Problema del Agrupamiento con Restricciones (PAR)},
	una generalización del problema del agrupamiento clásico incorporando un nuevo tipo de información (las restricciones).

	Este problema se basa en agrupar un conjunto de datos dado de tal forma que se cumplan las máximas restricciones posibles y
	se minimice la distancia media entre las instancias del mismo grupo.

	Para ello, usaremos el término \textbf{cluster} para referirnos a cada grupo. Cada cluster tiene un
	\textbf{centroide}, que es el centro geométrico de todos los datos que conforman el cluster. Cada instancia
	solo puede pertenecer a un cluster y su distancia al centroide de su cluster debe ser menor que al resto de centroides.

	Además, distinguiremos dos tipos de restricciones: las restricciones fuertes y las restricciones débiles.

	Las \textbf{restricciones fuertes} deben satisfacerse en la partición del conjunto de datos. Estas son:

	\begin{enumerate}
		\item Todos los clusters deben contener al menos una instancia.
		\item Cada instancia debe pertenecer a un solo cluster.
		\item La unión de los clusters debe ser el conjunto de datos.
	\end{enumerate}

	En cuanto a las \textbf{restricciones débiles}, nuestra solución tiene que incumplir el mínimo número de restricciones. Tenemos dos tipos:

	\begin{itemize}
		\item \textbf{Must-Link (ML).} Estas restricciones indican las parejas de instancias que deben pertenecer al mismo grupo.
		\item \textbf{Cannot-Link (CL).} Estas restricciones indican las parejas de instancias que deben pertenecer a distintos grupos.
	\end{itemize}

	El objetivo de este problema es minimizar la siguiente función
	$$fitness (solucion) = distancia_{intra-cluster} (solucion) + \lambda \cdot infeasibility (solucion)$$
	Donde

	\begin{itemize}
		\item $distancia_{intra-cluster} (solucion)$ es la media de las desviaciones intra-cluster de cada grupo. Cada desviación intra-cluster de cada grupo
		se calcula como la media de las instancias que lo forman a su centroide.
		\item $\lambda \in$ [ $0,1)$ es el cociente entre la distancia máxima que hay en el conjunto de datos y el número de restricciones presentes en el problema.
		\item $infeasibility (solucion)$ es el número de restricciones débiles que incumple nuestra solución.
	\end{itemize}

\newpage

\section{Descripción de la aplicación de los algoritmos empleados al problema}
	El lenguaje de programación que he utilizado para resolver este problema ha sido C++.

	\subsection{Esquema de representación}
		He implementado la clase \lstinline!PAR! que cuenta con los siguientes atributos:


		\begin{itemize}
			\item \lstinline!vector< vector<int> > restricciones!
			
				Es una matriz simétrica de enteros que contiene las restricciones. Para dos posiciones distintas de datos $i$, $j$ podemos acceder a esta matriz
			de tal forma que \lstinline!restricciones[i][j]! devuelve un valor, que indica el tipo de restricción entre dichos datos: $0$ (sin restricciones), $1$ (restricción ML) o $-1$ (restricción CL).
			
			\item \lstinline!vector< vector<int> > restriccionesML!
				
				Es una lista de enteros que contiene las restricciones Must-Link. Con \lstinline!restriccionesML[i][0]! obtenemos una posición en \lstinline!datos! tiene una restricción ML con la posición \lstinline!restriccionesML[i][1]!, y viceversa, donde $i$ varía entre $0$ y el número máximo de restricciones ML.
			
			\item \lstinline!vector< vector<int> > restriccionesCL!
			
				Es una lista de enteros que contiene las restricciones Cannot-Link. Con \lstinline!restriccionesCL[i][0]! obtenemos una posición en \lstinline!datos! que tiene una restricción CL con la posición \lstinline!restriccionesCL[i][1]!, y viceversa, donde $i$ varía entre $0$ y el número máximo de restricciones CL.
			
			\item \lstinline!vector< vector<double> > datos!
			
				Es una matriz simétrica de números reales que contiene las instancias de los datos en un espacio de $d$ dimensiones.
			
			\item \lstinline!vector<int> clusters!
			
				Es un vector de enteros que contiene los índices a los clusters de cada punto. Esto es, dada una posición $i$, obtenemos el cluster al que pertenece accediendo a \lstinline!clusters[i]!. Los valores están comprendidos entre $0$ y \textit{número de clusters - 1}.
			
			\item \lstinline!vector< vector<double> > centroides!
				
				Es una matriz de números reales que tiene los centroides de cada cluster. Podemos acceder al centroide del cluster $i$ accediendo a \lstinline!centroides[i]!, que nos devuelve un vector de dimensión $d$.
			
			\item \lstinline!vector< vector<double> > distancias!
			
				Es una matriz simétrica de números reales que contiene las distancias entre los datos. Para dos posiciones distintas de datos $i$, $j$ podemos acceder a la distancia entre estos con \lstinline!distancias[i][j]!.
			
			\item \lstinline!int num_clusters!
			
				Indica el número de clusters en los que agrupamos los datos.
			\item \lstinline!double lambda!

				Parámetro que toma valores en [$0,1)$ para asegurar que el factor \lstinline!infeasibility! tiene la suficiente importancia.
		\end{itemize}

		La \textbf{solución} se representa con un vector de enteros que contiene los índices a los clusters de cada punto.

	\subsection{Descripción en pseudocódigo de la función objetivo y los operadores comunes}

		La \textbf{función objetivo} de esta práctica es 
		$$fitness (solucion) = distancia_{intra-cluster} (solucion) + \lambda \cdot infeasibility (solucion)$$
		Nuestro problema debe devolver una solución que minimice esta función.
		Para calcular este valor, he realizado las siguientes operaciones.

		\begin{lstlisting}
		fitness = desviación_general + lambda * infeasibility
		\end{lstlisting}

		Donde la \textbf{desviación general} nos indica cuánto de cerca están todos nuestros datos del centroide del cluster al que pertenecen.

		\begin{lstlisting}
		Input: índices a los clusters {$l_1,...,l_{n-1}$}, número de clusters $num\_clusters$

		suma = 0.0

		for i $\in$ {0, ..., num_clusters-1} do
			suma += distancia intra cluster del cluster i
		end

		return (suma/num_clusters)
		\end{lstlisting}

		La \textbf{distancia intra cluster} de cada cluster nos muestra, dado un cluster, cuánto de cerca están los datos de dicho cluster a su centroide.

		\begin{lstlisting}
		Input: Conjunto de datos X de dimensión d, centroides {$\mu _1 , ..., \mu _k$}, cluster $c_j$, índices a los clusters {$l_0,...,l_{n-1}$}

		suma = 0.0
		contador = 0	// número de instancias que pertenecen al cluster $c_j$

		for i $\in$ {0,...,n-1} do
			if (la asignación $l_i$ pertenece al cluster $c_j$) do
				suma += distancia del dato $x_i$ al centroide $\mu _j$ del cluster $c_j$
				contador++
			end
		end

		return (suma/contador)
		\end{lstlisting}

		Otro operador que necesitamos para calcular la función \lstinline!fitness! es \textbf{\lstinline!lambda!}.
		Este parámetro toma valores comprendidos entre $0$ y $1$, y es útil para darle suficiente relevancia al factor \lstinline!infeasibility!. 

		\begin{lstlisting}
		lambda = distancia_máxima/número_total_restricciones
		\end{lstlisting}

		Finalmente, la \textbf{\lstinline!infeasibility!} nos indica el número de restricciones que nuestra solución incumple.
		Nótese que la matriz de restricciones es simétrica, luego solo se recorre la parte triangular superior.
		\begin{lstlisting}
		Input: Conjunto de restricciones R, índices a los clusters {$l_0,...,l_{n-1}$}

		infeasibility = 0

		for i $\in$ {0,...,n-1} do
			for j $\in$ {i+1,...,n-1} do
				if (hay restricción ML pero $l_i$ es distinto de $l_j$) do
					infeasibility++
				else if (hay restricción CL pero $l_i$ es igual a $l_j$) do
					infeasibility++
				end
			end
		end

		return infeasibility
		\end{lstlisting}

\newpage

\section{Pseudocódigo de la estructura del método de búsqueda y operaciones relevantes de cada algoritmo}
	El método de búsqueda por trayectorias simples que he usado en esta práctica es la \textbf{Búsqueda Local (BL)}.
	
	La búsqueda local consiste en, de forma aleatoria, generar una solución inicial y, al explorarla, generar posibles 
	vecinos y comprobar si alguno puede minimizar la función objetivo actual. En caso afirmativo, esa será nuestra nueva
	solución.

	Sin embargo, con este algoritmo obtenemos un mínimo local. Esto es, no nos garantiza alcanzar la solución óptima, aunque 
	puede darse el caso de que el mínimo local coincida con la solución óptima.

	\subsection{Generación de soluciones aleatorias}
		El algoritmo BL comienza generando una solución aleatoria de tamaño $n$. Para ello, inicializo el atributo \lstinline!clusters!, que 
		es un vector de enteros con índices a los clusters asociados a cada instancia, con valores aleatorios entre $0$ y $k-1$, 
		donde $k$ es el número de agrupamientos. Una vez inicializado, compruebo que no ha quedado ningún cluster sin instancia asignada.
		Si esto ha ocurrido, vuelvo a generar otra solución inicial. Finalmente, actualizo los centroides, pues hemos realizado cambios en los clusters.

		\begin{lstlisting}
		Input: índices a los clusters {$l_0,...,l_{n-1}$}

		do 
			recalcular = false
			
			for i $\in$ {0,...,n-1} do 
				Asignar a $l_i$ un número aleatorio entre 0 y k-1
			end
			
			// Comprobar que ningún cluster se ha quedado vacío
			Inicializar el contador de clusters a 0
			
			for i $\in$ {0,...,n-1} do 
				Incrementar el contador del cluster al que $l_i$ está asociado
			end
			
			for i $\in$ {0,...,k-1} do
				Comprobar si algún contador del cluster i es 0 (vacío)
			end
		while Haya clusters sin instancias asignadas
		
		Actualizar los centroides
		\end{lstlisting}

	\subsection{Operador de generación de vecino}
		El siguiente paso es recorrer la solución inicial calculada en el apartado anterior aleatoriamente
		y cambiar cada cluster por otros válidos, sus vecinos.

		Para realizar este cambio, en cada iteración sobre los datos he creado un vector de pares \lstinline!vecindarioVirtual! en el que el primer 
		elemento del par indica el cluster al que pertenece el dato y el segundo elemento indica otro cluster válido por el que se puede cambiar.

		\begin{lstlisting}
		Input: $x_j$ dato en la posición $j$, $c_j$ cluster asignado a $x_j$

		for i $\in$ {0,...,num_clusters-1} do 
			Si ($c_j$ es distinto de $i$) do
				Si (al asignarle el cluster $i$ a $x_j$ no se queda ningún cluster vacío) do 
					Añadir al vecindario virtual el par ($c_j$, i)
				end
			end 
		end
		\end{lstlisting}

	\subsection{Descripción en pseudocódigo del método de exploración del entorno}
		Para explorar el entorno, tendremos que recorrer aleatoriamente la solución actual y 
		en cada iteración generaremos un vecino. Comprobaremos si mejora la solución actual y 
		de hacerlo, sera nuestra nueva solución.
		\begin{lstlisting}
		fitnessActual = fitnessBL()
		infeasibilityActual, infeasibilityNueva = infeasibilityBL()

		do
			indicesDatos <- RandomShuffle({0,...,n-1})

			for i $\in$ indicesDatos && no hay mejora && número de evaluaciones < 100000 do
				Generar vecindario virtual del dato $x_i$
				indicesVecindarios <- Barajar los índices al vecindario

				for j $\in$ indicesVecindarios && no hay mejora && número de evaluaciones < 100000 do 
					Asignar el cluster $j$ al dato $x_i$
					Decrementar infeasibilityNueva la infeasibility que produce el dato $x_i$ asignado al cluster $l_i$
					Incrementar infeasibilityNueva la infeasibility que produce el dato $x_i$ asignado al cluster $j$
					Calcular fitnessNueva con infeasibilityNueva
					Incrementar el número de evaluaciones de la función fitness 

					Si (fitnessNueva es menor que fitnessActual) do 
						Actualizar fitnessActual e infeasibilityActual
					else 
						Reestablecer los clusters y la infeasibilityNueva
					end
				end
			end
		while Hay mejora y número de evaluaciones < 100000
		\end{lstlisting}
\newpage

\section{Pseudocódigo de los algoritmos de comparación}
		En esta práctica, he implementado el algoritmo \textbf{Greedy COPKM} para compararlo con el otro algoritmo de esta práctica (BL).
		Este algoritmo se basa en el algoritmo k-medias para agrupar un conjunto de datos con la diferencia de que tiene en cuenta 
		las restricciones asociadas a dicho conjunto.

		Al contrario que la Búsqueda Local, este algoritmo intenta minimizar el número de restricciones incumplidas aunque la desviación general 
		sea mayor.

		\subsection{Generación de centroides aleatorios}
		Este algoritmo comienza generando unos centroides aleatorios con valores en el dominio de los datos.

		\begin{lstlisting}
		Input: dimensión del conjunto de datos $n$, número de clusters $k$, centroides {$\mu _1 , ..., \mu _k$}
		
		Borrar el contenido de los centroides

		for i $\in$ {0,...,k-1} do 
			Asignar al centroide $\mu _i$ un vector de dimensión $n$ con valores aleatorios entre 0 y 1
		end
		\end{lstlisting}

		\subsection{Pseudocódigo para actualizar los centroides}
		En este algoritmo es necesario que se actualicen los centroides cada vez que se produzca un cambio en los clusters.

		\begin{lstlisting}
		Input: índices a los clusters {$l_1,...,l_n$}

		Comprobar que todos los elementos estén asociados a un cluster

		// Calcular el número de elementos de cada cluster
		for i $\in$ {0,...,n-1] do 
			Incrementar el contador de cluster al que pertenece $l_i$
		end 

		Inicializar los centroides a 0

		// Promediar las instancias asociadas a cada cluster
		for i $\in$ {0,...,n-1} do
			Sumar las coordenadas de los datos que pertenecen al cluster $l_i$ en su centroide $\mu _{l_i}$
		end
		
		for i $\in$ {0,...,k-1} do
			Asignar al centroide $\mu _i$ la división del centroide $\mu _i$ entre el número de elementos del cluster $c_i$
		end
		\end{lstlisting}

		\subsection{Pseudocódigo del algoritmo Greedy}
		Una vez inicializados los centroides, barajamos los datos para recorrerlos aleatoriamente y en cada iteración, asignamos 
		cada dato al cluster en el que menos restricciones incumple y al que menor distancia de encuentra.

		\begin{lstlisting}
		Input: conjunto de datos X

		Inicializar centroides aleatoriamente
		
		//Barajar los índices a los datos 
		RSI <- RandomShuffle({0,...,n-1})

		do 
			for i $\in$ RSI do 
				for j $\in$ {0,...,k-1} do 
					Calcular el número de restricciones que incumple el dato $x_i$ en el cluster $j$

					Si (el número de restricciones incumplidas es menor que el actual) do
						Guardar el número de restricciones incumplidas, el cluster y la distancia actuales por los nuevos valores
					Si (el número de restricciones incumplidas es igual que el actual) do 
						Si (la distancia del dato $x_i$ al cluster $j$ es menor que la distancia actual) do 
							Guardar el cluster y la distancia actuales por los nuevos valores
						end
					end
				end 

				Si (el cluster asignado a $x_i$ ha sido modificado) do 
					Actualizar el cluster asignado a $x_i$ por el nuevo valor
				end
			end

			Actualizar los centroides
		while Haya cambios en algún cluster

		// Comprobar que no ha quedado algún cluster vacío
		Si (no hay algún cluster vacío) do 
			Actualizar la desviación general, fitness e infeasibility
			Devolver la lista de clusters
		Si no
			Volver a ejecutar Greedy 
		end
		\end{lstlisting}
\newpage

\section{Procedimiento considerado para desarrollar la práctica}
	\subsection{Implementación a partir del código proporcionado en prácticas o a partir de cualquier otro}
	Para el desarrollo de mi práctica he necesitado generar números aleatorios, para ello he utilizado el código 
	proporcionado por los profesores que se encuentra en los archivo \lstinline!random.h! y \lstinline!random.cpp!.
	
	Además, para medir el tiempo he usado la librería \lstinline!chrono!.

	Para implementar la clase \lstinline!PAR! he usado la STL de C++ (\lstinline!vector! y \lstinline!pair!), la librería \lstinline!math!, etc.

	\subsection{Manual de usuario}
		\subsubsection{Estructura de carpetas}
			La organización de esta práctica se ha dividido en varias carpetas.
			
			\begin{itemize}
				\item \textbf{\lstinline!BIN/!}: carpeta que contiene el ejecutable.
				\item \textbf{\lstinline!BIN/DATA/!}: carpeta que contiene el conjunto de datos y sus restricciones.
				Al ejecutar la práctica, creará los archivos con los resultados de cada algoritmo.
				\item \textbf{\lstinline!FUENTES/include/!}: carpeta que contiene los archivos de cabecera.
				\item \textbf{\lstinline!FUENTES/src/!}: carpeta que contiene los archivos fuente.
				\item \textbf{\lstinline!FUENTES/obj/!}: carpeta que contiene los archivos objeto.
			\end{itemize}

		\subsubsection{Compilación}
			Para compilar la práctica, he creado un fichero \lstinline!Makefile!. Por lo que bastará con ejecutar el siguiente comando
		\begin{lstlisting}
		make
		\end{lstlisting}
			Nos creará en la carpeta \lstinline!BIN/! un ejecutable llamado \lstinline!practica1!.

		\subsubsection{Ejecución}
			Para ejecutar la práctica, necesitamos pasarle al ejecutable los siguientes parámetros.

		\begin{lstlisting}
		./BIN/practica1 ficheroDatos.dat ficheroRestricciones.const 
		númeroDeClusters semilla
		\end{lstlisting}

			Por ejemplo, si queremos ejecutar la práctica con los datos de \lstinline!zoo! con el $10$\% de restricciones con la semilla $22$,
			tendremos que hacer lo siguiente.

		\begin{lstlisting}
		./BIN/practica1 zoo_set.dat zoo_set_const_10.const 7 22 
		\end{lstlisting}

			En la terminal veremos qué algoritmos se están ejecutando y, una vez terminen, mostrarán un mensaje con la ruta donde se encuentra 
			el fichero con los resultados.
\newpage

\section{Experimentos y análisis de resultados}


\subsection{Casos del problema empleados y valores de los parámetros considerados en las ejecuciones de cada algoritmo}

\subsubsection{Casos del problema empleados}

Para realizar esta práctica, he considerado tres conjuntos de datos:

\begin{enumerate}
	\item \textbf{Zoo:} contiene los datos de un conjunto de animales, cada uno con 16 atributos sobre sus características. 
	El objetivo es clasificar 101 instancias de animales en 7 clases según sus atributos.
	\item \textbf{Glass:} contiene los datos de un conjunto de vidrios, cada uno con 5 atributos sobre sus componentes químicos.
	El objetivo es clasificar 214 instancias de vidrios en 7 clases según sus atributos.
	\item \textbf{Bupa:} contiene los datos de un conjunto de personas, cada una con 5 atributos sobre sus hábitos de consumo de alcohol.
	El objetivo es clasificar 345 instancias de personas en 16 clases según sus atributos.
\end{enumerate}

Cada conjunto de datos tiene asociados dos conjuntos de restricciones, correspondientes al 10\% y al 20\% 
del total de restricciones posibles. Estas restricciones serán muy importantes a la hora de determinar una solución,
pues indican qué conjuntos de datos son los que deben ir en la misma clase, aunque parezcan muy distintos, y los que deban ir a clases distintas, aunque parezcan ser similares.
Los algoritmos tendrán en cuenta estas restricciones para agrupar las instancias.

En total, el PAR trabajará con 6 instancias generadas a partir de los datos anteriores.

\subsubsection{Valores de los parámetros considerados}

Para determinar si los algoritmos funcionan correctamente, necesitamos ejecutarlos de formas diferentes. Para ello, inicializamos 
una semilla y a partir de esta, los algoritmos tomarán secuencias distintas aleatorias y, por ello, resultados diferentes.
Para realizar las ejecuciones, he elegido las siguientes cinco semillas de forma aleatoria: $7$, $22$, $100$, $222$, $273687$.
Por lo que para cada semilla, conjunto de datos y conjunto de restricciones, he realizado una ejecución. Así, he realizado $30$ ejecuciones en total por algoritmo.

\subsection{Resultados obtenidos}

A continuación se muestran los resultados obtenidos con los distintos algoritmos y las medias.

\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo Greedy en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   & 17 & 0.0541104 & 1.08773 & 0.006 &  			9 & 0.00240336 & 0.37555 & 0.039 			& 55 & 0.0165283 & 0.251691 & 0.224  \\ \hline
	22 & 9 & 0.135563 & 1.10856 & 0.004 &			1 & 0.0164101 & 0.381684 & 0.034			& 37 & 0.0149684 & 0.245308 & 0.344		\\ \hline
	100 & 0 & 0.0110949 & 0.915895 & 0.010 		&		4 & 0.0548859 & 0.423112 & 0.029			& 89 & 0.0115209 & 0.255796 & 0.272		\\ \hline
	222 & 1 & 0.00188341 & 0.910494 & 0.006     &		6 & 0.0128024 & 0.382997 & 0.057			& 16 & 0.00465167 & 0.229363 & 0.293		\\ \hline
	273687 & 10 & 0.148098 & 1.12867 & 0.004     &  		3 & 0.0148285 & 0.352414 & 0.030			& 11 & 0.0139084 & 0.23728 & 0.513		\\ \hline
	\textbf{Media} & 7.4 & 0.06815286 & 1.0302698 & 0.006		& 4.6 & 0.020266052 & 0.3831514 & 0.0378     & 41.6 & 0.012315534 & 0.2438876 & 0.3292  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo BL en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7      & 14 & 0.293276 & 0.71761 & 0.389                     & 18 & 0.121449 & 0.260554 & 1.094 			 			& 140 & 0.114836 & 0.143106 & 8.943  \\ \hline
	22     & 18 & 0.376795 & 0.664402 & 0.522                    &	39 & 0.154189 & 0.248479 & 1.061					    & 81 & 0.0998916 & 0.142239 & 8.271		\\ \hline
	100    & 15 & 0.294719 & 0.723745 & 0.592		             &	43 & 0.153585 & 0.253019 & 1.338				        & 127 & 0.108606 & 0.145852 & 10.058		\\ \hline
	222    & 19 & 0.296847 & 0.751928 & 0.707                    &	49 & 0.170574 & 0.241935 & 0.978				        & 133 & 0.105082 & 0.150984 & 5.437 		\\ \hline
	273687 & 9 & 0.29219 & 0.680808 & 0.503                    &  	21 & 0.124522 & 0.260433 & 1.195				    & 107 & 0.108612 & 0.140486 & 10.078 \\ \hline
	\textbf{Media} & 15 & 0.3107654  & 0.7076986 & 0.5426 & 34 & 0.1448638 & 0.252884 & 1.1332 			& 117.6 & 0.10740552 & 0.1747302 & 8.5574                    \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}


\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados globales en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Algoritmo}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	\textbf{COPKM}      & 7.4 & 0.06815286 & 1.0302698 & 0.006		& 4.6 & 0.0202660 & 0.3831514 & 0.0378     & 41.6 & 0.0123155 & 0.2438876 & 0.3292  \\ \hline
	\textbf{BL}    & 15 & 0.3107654  & 0.7076986 & 0.5426 & 34 & 0.1448638 & 0.252884 & 1.1332 			& 117.6 & 0.1074055 & 0.1747302 & 8.5574		\\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	


\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo Greedy en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7      & 0 & 2.22045e-16 & 0.9048 & 0.006                    & 0 & 0.0148355 & 0.349455 & 0.025 			 			& 2 & 0.0178596 & 0.238562 & 0.180  \\ \hline
	22     &  1 & 0.0295632 & 0.938401 & 0.006                    &	0 & 0.052908 & 0.311382 & 0.020					    & 2 & 0.0088525 & 0.229555 & 0.150		\\ \hline
	100    &   4 & 0.0355002 & 0.956452 & 0.008		             &	1 & 0.00854759 & 0.356263 & 0.020				        & 16 & 0.0176109 & 0.240266 & 0.200		\\ \hline
	222    &  3 & 0.0772552 & 0.994169 & 0.006                    &	6 & 0.0199431 & 0.347471 & 0.035				        & 2 & 0.0253277 & 0.24603 & 0.320		\\ \hline
	273687 &  1 & 0.0449131 & 0.953751 & 0.006                   &  1 & 0.00035010 & 0.365161 & 0.020					    & 8 & 0.0120281 & 0.233567 & 0.199		\\ \hline
	\textbf{Media} & 1.8 & 0.0374463 &  0.9495146  & 0.0064       & 1.6 & 0.01931685 & 0.345946 & 0.024     & 6 & 0.01633576 & 0.2380166 & 0.2098                  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo BL en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7      & 10 & 0.171019 & 0.774162 & 0.345                    &  119 & 0.160275 & 0.265967 & 1.015			 			&  225 & 0.11033 & 0.141468 & 8.555 \\ \hline
	22     & 14 & 0.171457 & 0.789876 & 0.372                   &	29 & 0.113331 & 0.266057 & 1.023					    & 241 & 0.110878 & 0.143151 & 10.163		\\ \hline
	100    & 33 & 0.310457 & 0.727599 & 0.486		             &	119 & 0.155487 & 0.270756 & 1.345				        & 274 & 0.10985 & 0.148781 & 10.104		\\ \hline
	222    &  21 & 0.171234 & 0.818365 & 0.341                  &	117 & 0.155015 & 0.270187 & 1.182				        & 162 & 0.0996144 & 0.143399 & 9.958		\\ \hline
	273687 &   30 & 0.194177 & 0.831766 & 0.383                  &  130 & 0.163206 & 0.268763 & 1.048					    & 174 & 0.0941389 & 0.150548 & 7.427		\\ \hline
	\textbf{Media}  & 21.6 & 0.2036688 & 0.7883536 & 0.3854     & 102.8 & 0.1494628 & 0.268346 & 1.1226 & 215.2 & 0.10496226 & 0.1454694 & 9.2414                  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

\begin{table}[H]
	\scriptsize

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados globales en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Algoritmo}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{ErrorDist} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	\textbf{COPKM}    & 1.8 & 0.0374463 &  0.9495146  & 0.0064       & 1.6 & 0.0193168 & 0.345946 & 0.024     & 6 & 0.01633576 & 0.2380166 & 0.2098  \\ \hline
	\textbf{BL}   & 21.6 & 0.2036688 & 0.7883536 & 0.3854     & 102.8 & 0.1494628 & 0.268346 & 1.1226 & 215.2 & 0.10496226 & 0.1454694 & 9.2414 		\\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\subsection{Análisis de resultados}


En los resultados obtenidos por el algoritmo Greedy, observamos que se incumplen menos \textbf{restricciones} que con el algoritmo BL.
Lo mismo ocurre con la \textbf{desviación general} de ambos algoritmos. Esto se debe a que el algoritmo Greedy intenta minimizar estas dos medidas, en especial el número de restricciones incumplidas.
Hay que destacar que el número de restricciones incumplidas por el algoritmo Greedy con el 10\% de restricciones es mayor que con el 20\% de restricciones,
mientras que con el algoritmo BL se incrementa el número de restricciones incumplidas con el 20\% de restricciones, con respecto al 10\% de restricciones.
En cuanto a la desviación general, este valor se mantiene parecido o incluso menor cuando pasamos de considerar 10\% de restricciones a 20\% de restricciones.

Sin embargo, el algoritmo BL muestra mejor resultados en el \textbf{agregado}, pues el objetivo de este algoritmo es optimizar la función que calcula este valor, teniendo 
en cuenta la distancia y el número de restricciones incumplidas, dándole a esta última medida la suficiente relevancia. 

También hay que tener en cuenta que el algoritmo Greedy emplea mucho menos \textbf{tiempo} (medido en segundos) que el algoritmo BL, pues este último algoritmo tiene que barajar el entorno y evaluar la 
función objetivo repetidas veces. Con el conjunto de datos Zoo y Glass no se nota demasiado la diferencia, pero con Bupa si es considerable la cantidad de tiempo. Esto puede deberse 
a que este último conjunto de datos se agrupa en 16 clases, por lo que el algoritmo BL tendrá que generar más vecinos y comprobar si optimizan la función objetivo.

En resumen, tanto con el 10\% y 20\% de restricciones, que el algoritmo BL nos dé un valor de agrupamiento menor al del algoritmo Greedy nos indica que BL se comporta mejor en cuanto 
a la búsqueda de la solución. Sin embargo, también tenemos que tener en cuenta que BL obtiene agrupamientos menos respetuosos con las restricciones y mayor desviación hay con los datos,
lo que genera una peor calidad. Con respecto al tiempo, en Zoo y Glass apenas se aprecia la diferencia, pero en Bupa sí es considerablemente peor por lo que la calidad de BL tiende a ser mucho peor que 
Greedy. En conclusión, el algoritmo Greedy es mejor que la búsqueda local.

\newpage

\section{Referencias bibliográficas u otro tipo de material consultado}

\begin{itemize}
	\item Material proporcionado por los profesores sobre la asignatura.
	
		\url{https://sci2s.ugr.es/node/124}
	\item Material consultado para medir tiempos.
	
		\url{https://www.geeksforgeeks.org/measure-execution-time-function-cpp/}
\end{itemize}