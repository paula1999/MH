\section{Descripción o formulación del problema}
	Esta práctica consiste en encontrar una solución al \textbf{Problema del Agrupamiento con Restricciones (PAR)},
	una generalización del problema del agrupamiento clásico incorporando un nuevo tipo de información (las restricciones).

	Este problema se basa en agrupar un conjunto de datos dado de tal forma que se cumplan las máximas restricciones posibles y
	se minimice la distancia media entre las instancias del mismo grupo.

	Para ello, usaremos el término \textbf{cluster} para referirnos a cada grupo. Cada cluster tiene un
	\textbf{centroide}, que es el centro geométrico de todos los datos que conforman el cluster. Cada instancia
	solo puede pertenecer a un cluster y su distancia al centroide de su cluster debe ser menor que al resto de centroides.

	Además, distinguiremos dos tipos de restricciones: las restricciones fuertes y las restricciones débiles.

	Las \textbf{restricciones fuertes} deben satisfacerse en la partición del conjunto de datos. Estas son:

	\begin{enumerate}
		\item Todos los clusters deben contener al menos una instancia.
		\item Cada instancia debe pertenecer a un solo cluster.
		\item La unión de los clusters debe ser el conjunto de datos.
	\end{enumerate}

	En cuanto a las \textbf{restricciones débiles}, nuestra solución tiene que incumplir el mínimo número de restricciones. Tenemos dos tipos:

	\begin{itemize}
		\item \textbf{Must-Link (ML).} Estas restricciones indican las parejas de instancias que deben pertenecer al mismo grupo.
		\item \textbf{Cannot-Link (CL).} Estas restricciones indican las parejas de instancias que deben pertenecer a distintos grupos.
	\end{itemize}

	El objetivo de este problema es minimizar la siguiente función
	$$fitness (solucion) = distancia_{intra-cluster} (solucion) + \lambda \cdot infeasibility (solucion)$$
	Donde

	\begin{itemize}
		\item $distancia_{intra-cluster} (solucion)$ es la media de las desviaciones intra-cluster de cada grupo. Cada desviación intra-cluster de cada grupo
		se calcula como la media de las instancias que lo forman a su centroide.
		\item $\lambda \in$ [ $0,1)$ es el cociente entre la distancia máxima que hay en el conjunto de datos y el número de restricciones presentes en el problema.
		\item $infeasibility (solucion)$ es el número de restricciones débiles que incumple nuestra solución.
	\end{itemize}

\newpage

\section{Descripción de la aplicación de los algoritmos empleados al problema}
	El lenguaje de programación que he utilizado para resolver este problema ha sido C++.

	\subsection{Esquema de representación}
		He implementado la clase \lstinline!PAR! que cuenta con los siguientes atributos:


		\begin{itemize}
			\item \lstinline!vector< vector<int> > restricciones!
			
				Es una matriz simétrica de enteros que contiene las restricciones. Para dos posiciones distintas de datos $i$, $j$ podemos acceder a esta matriz
			de tal forma que \lstinline!restricciones[i][j]! devuelve un valor, que indica el tipo de restricción entre dichos datos: $0$ (sin restricciones), $1$ (restricción ML) o $-1$ (restricción CL).
			
			\item \lstinline!vector< vector<int> > restriccionesML!
				
				Es una lista de enteros que contiene las restricciones Must-Link. Con \lstinline!restriccionesML[i][0]! obtenemos una posición en \lstinline!datos! tiene una restricción ML con la posición \lstinline!restriccionesML[i][1]!, y viceversa, donde $i$ varía entre $0$ y el número máximo de restricciones ML.
			
			\item \lstinline!vector< vector<int> > restriccionesCL!
			
				Es una lista de enteros que contiene las restricciones Cannot-Link. Con \lstinline!restriccionesCL[i][0]! obtenemos una posición en \lstinline!datos! que tiene una restricción CL con la posición \lstinline!restriccionesCL[i][1]!, y viceversa, donde $i$ varía entre $0$ y el número máximo de restricciones CL.
			
			\item \lstinline!vector< vector<double> > datos!
			
				Es una matriz simétrica de números reales que contiene las instancias de los datos en un espacio de $d$ dimensiones.
			
			\item \lstinline!vector<int> clusters!
			
				Es un vector de enteros que contiene los índices a los clusters de cada punto. Esto es, dada una posición $i$, obtenemos el cluster al que pertenece accediendo a \lstinline!clusters[i]!. Los valores están comprendidos entre $0$ y \textit{número de clusters - 1}.
			
			\item \lstinline!vector< vector<double> > centroides!
				
				Es una matriz de números reales que tiene los centroides de cada cluster. Podemos acceder al centroide del cluster $i$ accediendo a \lstinline!centroides[i]!, que nos devuelve un vector de dimensión $d$.
			
			\item \lstinline!vector< vector<double> > distancias!
			
				Es una matriz simétrica de números reales que contiene las distancias entre los datos. Para dos posiciones distintas de datos $i$, $j$ podemos acceder a la distancia entre estos con \lstinline!distancias[i][j]!.
			
			\item \lstinline!int num_clusters!
			
				Indica el número de clusters en los que agrupamos los datos.
			\item \lstinline!double lambda!

				Parámetro que toma valores en [$0,1)$ para asegurar que el factor \lstinline!infeasibility! tiene la suficiente importancia.
		
		\end{itemize}

		La \textbf{solución} se representa con un vector de enteros que contiene los índices a los clusters de cada punto.

	\subsection{Descripción en pseudocódigo de la función objetivo y los operadores comunes}

		La \textbf{función objetivo} de esta práctica es 
		$$fitness (solucion) = distancia_{intra-cluster} (solucion) + \lambda \cdot infeasibility (solucion)$$
		Nuestro problema debe devolver una solución que minimice esta función.
		Para calcular este valor, he realizado las siguientes operaciones.

		\footnotesize
		\begin{lstlisting}
		fitness = desviación_general + lambda * infeasibility
		\end{lstlisting}
		\normalsize

		Donde la \textbf{desviación general} nos indica cuánto de cerca están todos nuestros datos del centroide del cluster al que pertenecen.

		\footnotesize
		\begin{lstlisting}
		Input: índices a los clusters {$l_1,...,l_{n-1}$}, número de clusters num_clusters

		suma = 0.0

		for i $\in$ {0, ..., num_clusters-1} do
			suma += distancia intra cluster del cluster i
		end

		return (suma/num_clusters)
		\end{lstlisting}
		\normalsize

		La \textbf{distancia intra cluster} de cada cluster nos muestra, dado un cluster, cuánto de cerca están los datos de dicho cluster a su centroide.

		\footnotesize
		\begin{lstlisting}
		Input: Conjunto de datos $X$ de dimensión $d$, centroides {$\mu _1 , ..., \mu _k$}, cluster $c_j$, índices a los clusters {$l_0,...,l_{n-1}$}

		suma = 0.0
		contador = 0	// número de instancias que pertenecen al cluster $c_j$

		for i $\in$ {0,...,n-1} do
			if (la asignación $l_i$ pertenece al cluster $c_j$) do
				suma += distancia del dato $x_i$ al centroide $\mu _j$ del cluster $c_j$
				contador++
			end
		end

		return (suma/contador)
		\end{lstlisting}
		\normalsize

		Otro operador que necesitamos para calcular la función \lstinline!fitness! es \textbf{\lstinline!lambda!}.
		Este parámetro toma valores comprendidos entre $0$ y $1$, y es útil para darle suficiente relevancia al factor \lstinline!infeasibility!. 

		\footnotesize
		\begin{lstlisting}
		lambda = distancia_máxima/número_total_restricciones
		\end{lstlisting}
		\normalsize

		Finalmente, la \textbf{\lstinline!infeasibility!} nos indica el número de restricciones que nuestra solución incumple.
		Nótese que la matriz de restricciones es simétrica, luego solo se recorre la parte triangular superior.

		\newpage

		\footnotesize
		\begin{lstlisting}
		Input: Conjunto de restricciones $R$, índices a los clusters {$l_0,...,l_{n-1}$}

		infeasibility = 0

		for i $\in$ {0,...,n-1} do
			for j $\in$ {i+1,...,n-1} do
				if (hay restricción ML pero $l_i$ es distinto de $l_j$) do
					infeasibility++
				else if (hay restricción CL pero $l_i$ es igual a $l_j$) do
					infeasibility++
				end
			end
		end

		return infeasibility
		\end{lstlisting}
		\normalsize

\newpage

\section{Pseudocódigo de la estructura del método de búsqueda y operaciones relevantes de cada algoritmo}
	\subsection{Algoritmo de Búsqueda Local}

	El método de búsqueda por trayectorias simples que he usado en la práctica 1 es la \textbf{Búsqueda Local (BL)}.
	
	La búsqueda local consiste en, de forma aleatoria, generar una solución inicial y, al explorarla, generar posibles 
	vecinos y comprobar si alguno puede minimizar la función objetivo actual. En caso afirmativo, esa será nuestra nueva
	solución.

	Sin embargo, con este algoritmo obtenemos un mínimo local. Esto es, no nos garantiza alcanzar la solución óptima, aunque 
	puede darse el caso de que el mínimo local coincida con la solución óptima.

	\subsubsection{Generación de soluciones aleatorias}
		El algoritmo BL comienza generando una solución aleatoria de tamaño $n$. Para ello, inicializo el atributo \lstinline!clusters!, que 
		es un vector de enteros con índices a los clusters asociados a cada instancia, con valores aleatorios entre $0$ y $k-1$, 
		donde $k$ es el número de agrupamientos. Una vez inicializado, compruebo que no ha quedado ningún cluster sin instancia asignada.
		Si esto ha ocurrido, vuelvo a generar otra solución inicial. Finalmente, actualizo los centroides, pues hemos realizado cambios en los clusters.

		\footnotesize
		\begin{lstlisting}
		Input: índices a los clusters {$l_0,...,l_{n-1}$}

		do 
			recalcular = false
			
			for i $\in$ {0,...,n-1} do 
				Asignar a $l_i$ un número aleatorio entre 0 y k-1
			end
			
			// Comprobar que ningún cluster se ha quedado vacío
			Inicializar el contador de clusters a 0
			
			for i $\in$ {0,...,n-1} do 
				Incrementar el contador del cluster al que $l_i$ está asociado
			end
			
			for i $\in$ {0,...,k-1} do
				Comprobar si algún contador del cluster i es 0 (vacío)
			end
		while Haya clusters sin instancias asignadas
		
		Actualizar los centroides
		\end{lstlisting}
		\normalsize

	\subsubsection{Operador de generación de vecino}
		El siguiente paso es recorrer la solución inicial calculada en el apartado anterior aleatoriamente
		y cambiar cada cluster por otros válidos, sus vecinos.

		Para realizar este cambio, en cada iteración sobre los datos he creado un vector de pares \lstinline!vecindarioVirtual! en el que el primer 
		elemento del par indica el cluster al que pertenece el dato y el segundo elemento indica otro cluster válido por el que se puede cambiar.

		\footnotesize
		\begin{lstlisting}
		Input: $x_j$ dato en la posición $j$, $c_j$ cluster asignado a $x_j$

		for i $\in$ {0,...,num_clusters-1} do 
			Si ($c_j$ es distinto de $i$) do
				Si (al asignarle el cluster $i$ a $x_j$ no se queda ningún cluster vacío) do 
					Añadir al vecindario virtual el par ($c_j$, i)
				end
			end 
		end
		\end{lstlisting}
		\normalsize

	\subsubsection{Descripción en pseudocódigo del método de exploración del entorno}
		Para explorar el entorno, tendremos que recorrer aleatoriamente la solución actual y 
		en cada iteración generaremos un vecino. Comprobaremos si mejora la solución actual y 
		de hacerlo, sera nuestra nueva solución.
		
		\footnotesize
		\begin{lstlisting}
		fitnessActual = fitnessBL()
		infeasibilityActual, infeasibilityNueva = infeasibilityBL()

		do
			indicesDatos <- RandomShuffle({0,...,n-1})

			for i $\in$ indicesDatos && no hay mejora && número de evaluaciones < 100000 do
				Generar vecindario virtual del dato $x_i$
				indicesVecindarios <- Barajar los índices al vecindario

				for j $\in$ indicesVecindarios && no hay mejora && número de evaluaciones < 100000 do 
					Asignar el cluster $j$ al dato $x_i$
					Decrementar infeasibilityNueva la infeasibility que produce el dato $x_i$ asignado al cluster $l_i$
					Incrementar infeasibilityNueva la infeasibility que produce el dato $x_i$ asignado al cluster $j$
					Calcular fitnessNueva con infeasibilityNueva
					Incrementar el número de evaluaciones de la función fitness 

					Si (fitnessNueva es menor que fitnessActual) do 
						Actualizar fitnessActual e infeasibilityActual
					else 
						Reestablecer los clusters y la infeasibilityNueva
					end
				end
			end
		while Hay mejora y número de evaluaciones < 100000
			
	\end{lstlisting}
	\normalsize
		

	\subsection{Algoritmos evolutivos basados en poblaciones}
		\subsubsection{Introducción}
		La práctica 2 consiste en estudiar el funcionamiento de las Técnicas de Búsqueda basadas en Poblaciones para el PAR.
		A diferencia de la Búsqueda Local, con estos algoritmos trabajamos sobre un conjunto de soluciones, llamado \textbf{población}.
		Cada solución que forma parte de la población decimos que es un \textbf{cromosoma}. A su vez, cada cromosoma está formado por \textbf{genes}.
		

		Estos conceptos los podemos trasladar al PAR de la siguiente forma:

		\begin{itemize}
			\item \textbf{Población}: representa un conjunto de cromosomas, es decir, un conjunto de soluciones.
			\item \textbf{Cromosoma}: representa una solución, que está formada por genes.
			\item \textbf{Gen}: representa un elemento de una solución. Además, cada elemento tiene asociado el cluster al que pertenece.
		\end{itemize}

		Estos algoritmos se basan en aplicar diferentes operadores sobre la población para mejorar cada cromosoma. Así, podremos 
		explorar el espacio de búsqueda y obtendremos soluciones diversas, por lo que evitará estancarse en mínimos locales, como ocurría con la
		Búsqueda Local.

		En esta práctica se han implementado dos tipos de algoritmos evolutivos.

		\begin{itemize}
			\item \textbf{Algoritmos Genéticos (AGs)}. Se implementarán dos variantes generacionales elitistas (\textbf{AGGs}) y otras dos estacionarias (\textbf{AGEs}).
			\item \textbf{Algoritmos Meméticos (AMs)}. Se implementarán tres variantes basadas en un AGG.
		\end{itemize}

		Ambos algoritmos tienen en común el esquema de representación, la función objetivo, la generación de la solución inicial, el esquema de generación 
		de vecinos y el criterio de aceptación ya comentados anteriormente.

		En estos algoritmos, a partir de una población inicial, podemos seleccionar algunos individuos que actúen como padres y obtener a partir de ellos unos hijos. A estos
		hijos se les aplicarán ciertas mutaciones para garantizar la diversidad y, finalmente, estos formarán parte de la nueva población.

		\subsubsection{Algoritmos Genéticos (AG)}

		\paragraph{Variantes implementadas}
		$ $\\
		En esta práctica se han implementado dos variantes generacionales elitistas (\textbf{AGGs}) y otras dos estacionarias (\textbf{AGEs}), que se distinguen por el esquema de evolución y el operador de cruce 
		empleado.
		
		En cuanto a los valores de los parámetros, en ambos casos, se establece que el tamaño de la población será de $50$ cromosomas, la probabilidad de cruce será de $0.7$ por cromosoma, la probabilidad de mutación será de $0.1/numero\_de\_genes$ por gen y 
		el criterio de parada será de relizar 100000 evaluaciones de la función objetivo, el tamaño de la población será de $50$ cromosomas.
		Todos los Algoritmos Genéticos los he implementado en la misma función, estableciento al inicio los valores de los parámetros correspondientes en cada caso.
\newpage
		\paragraph{Esquema de evolución}
		$ $\\
		El esquema de evolución consta de 4 pasos.

		\begin{enumerate}
			\item \textbf{Selección.} Se han implementado las siguientes variantes del operador de selección:
			\begin{itemize}
				\item \textbf{Versión basada en el esquema generacional con elitismo (AGG)}. La población seleccionada tendrá exactamente el mismo tamaño que la población inicial.
				\item \textbf{Versión basada en el esquema estacionario (AGE)}. De la población actual, solo se seleccionarán dos padres.
			\end{itemize}

				Para realizar esta selección, se ha aplicado un \textbf{torneo binario} entre los padres. Esto es, se han elegido aleatoriamente dos padres de la población actual y, entre ellos, el padre que menor función objetivo tenga 
				será quien formará parte de la siguiente población. Repetimos este proceso hasta conseguir el tamaño de la siguiente población deseado.
			
				\item \textbf{Cruce.} Una vez obtenida la población formada por unos padres, los agruparemos por parejas y de ellos obtendremos unos hijos. Para ello, tenemos que tener en cuenta que los padres cruzan con una cierta probabilidad.
				Además, se implementarán dos variantes del operador de cruce: 
				
				\begin{itemize}
					\item \textbf{Operador de cruce uniforme (UN).} Al aplicar este operador a una pareja de padres, el resultado será un hijo con la mitad de genes de un padre y la otra mitad del otro padre. Para ello, se elige aleatoriamente la mitad 
					de la mitad de un padre y el resto, se escoge del otro padre. De esta forma combinamos uniformemente las características de ambos padres. 

					\item \textbf{Operador de cruce por segmento fijo (SF).} En este operador, seleccionamos de forma aleatoria y copiamos un segmento continuo de genes de un padre y el resto de genes, se determinan de igual forma que en el cruce uniforme. Con este operador se obtiene mayor diversidad.
				\end{itemize}

				Sin embargo, en ambos cruces podemos obtener un resultado puede ser incorrecto, pues algún cluster se puede quedar sin instancias asignadas. Para ello, realizaremos una reparación del cromosoma obtenido.
			\item \textbf{Mutación.} Los hijos obtenidos pueden experimentar, con una probabilidad muy baja, cambios en sus genes. Esto es, tendremos un operador de mutación que, con cierta probabilidad, determinará 
				si algún gen puede mutar, lo que significa que dicha instancia puede pasar a formar parte de otro cluster. En esta práctica haremos uso del operador de mutación uniforme.

				Sin embargo, obtenemos el mismo problema que al cruzar dos padres, en el resultado puede haber algún cluster sin instancias asignadas. Se soluciona de la misma forma.

			\item \textbf{Reemplazamiento.} En esta fase, la población obtenida sustituirá a la población actual. En el caso de que el reemplazamiento se haga con elitismo, 
				se conservará el mejor cromosoma de la población actual en la nueva población.
		\end{enumerate}
		\newpage
		\paragraph{Generación de la población inicial}
		$ $\\
		\footnotesize
		\begin{lstlisting}
			Input: tamaño de la población actual $M$, número de clusters $k$, número de genes $n$
			
			cromosoma = vector de enteros vacío
			pActual = matriz de enteros vacía
			pActualFitness = vector vacío

			Para i $\in$ {0,...,M-1}
				Hacer
					cromosoma.clear()
					
					Para i $\in$ {0,...,n-1} do 
						gen = número aleatorio entero entre [0, k)
						cromosoma.añadir(gen)
					end
					
					// Comprobar que ningún cluster se ha quedado vacío
					Inicializar el contador de clusters a 0
					
					Para i $\in$ {0,...,n-1} do 
						Incrementar el contador del cluster al que $cromosoma[i]$ está asociado
					end
					
					Para i $\in$ {0,...,k-1} do
						Comprobar si algún contador del cluster i es 0 (vacío)
					end
				Mientras (haya clusters sin instancias asignadas)

				pActual.añadir(cromosoma)
				pActualFitness.añadir(fitness(pActual[i]))
			end

			return pActual, pActualFitness
		\end{lstlisting}
		\normalsize

		\paragraph{Operador selección}
		$ $\\
		Este operador es común a ambas variantes generacionales del Algoritmo Genético, la única diferencia es el número de iteraciones realizadas.

		\footnotesize
		\begin{lstlisting}
			Input: población actual $pActual$, fitness de la población actual $pActualFitness$, tamaño de la población actual $M$, tamaño de la población seleccionada $m$

			pSiguiente = vector de enteros vacío

			Para i $\in$ {0, ..., m}
				c1 = número aleatorio entero en [0, M)

				Hacer 
					c2 = número aleatorio entero en [0, M)
				Mientras (c1 == c2)

				Si pActualFitness[c1] > pActualFitness[c2] 
					pSiguiente.añadir(pActual[c2])
				Si no
					pSiguiente.añadir(pActual[c1])
				end 
			end
			return pSiguiente
		\end{lstlisting}
		\normalsize
		
		\paragraph{Operador de reparación}
		$ $\\
		Con este operador, comprobamos si un cromosoma no es válido y, en ese caso, lo reparamos.

		\footnotesize 
		\begin{lstlisting}
			Input: cromosoma $C$, número de genes $n$, número de clusters $k$

			contador = vector de enteros de tamaño $k$ inicializado a 0
			
			Para i $\in$ {0,...,n}
				Incrementar el contador del cluster al que $C_i$ está asociado
			end
			
			Para i $\in$ {0,...,contador.size()}
				Si el contador del cluster i es 0 (vacío)
					Hacer 
						j = número aleatorio entero en [0, n)
					Mientras (contador[C[j]] - 1 <= 0)

					C[j] = i
					Decrementar contador[C[j]]
					Incrementar contador[i]
				end
			end

			return C
		\end{lstlisting}
		\normalsize

		\paragraph{Operador de cruce}
		$ $\\
		Para realizar un cruce, tenemos que tener en cuenta que la probabilidad con la que se cruzan dos individuos es de $0.7$.
		Para no tener que elegir números aleatorios en cada iteración, calculamos a priori cuántos cruces debe haber, esto es $nCruces = probCruce * m/2.0$,
		donde $nCruces$ es el número de cruces, $probCruce$ es la probabilidad de cruzar y $m$ es el tamaño de la población seleccionada.

		\footnotesize 
		\begin{lstlisting}
			Input = población siguiente $pSiguiente$, tamaño de la población siguiente $m$, número de cruces $nCruces$
			
			numCruces = nCruces

			Para i $\in$ {0,...,m} && nCruces > 0
				Si i es par
					pSiguiente.añadir(operadorCruce(pSiguiente[i], pSiguiente[i+1]))
				Si no
					pSiguiente.añadir(operadorCruce(pSiguiente[i], pSiguiente[i-1]))
					Decrementar nCruces
				end 
			end 

			// Eliminar los padres que han cruzado
			Para i $\in$ {0,...,numCruces}
				pSiguiente.eliminar(pSiguiente.begin())
				pSiguiente.eliminar(pSiguiente.begin())
			end

			return pSiguiente
		\end{lstlisting}
		\normalsize

		El siguiente esquema es independiente del operador de cruce que usemos, solo tendríamos que sustituir \lstinline! operadorCruce! por el que queramos usar.
		
		\subparagraph{Operador de cruce uniforme (UN)}
		$ $\\

		\footnotesize 
		\begin{lstlisting}
			Input: primer padre $p1$, segundo padre $p2$, número de genes $n$

			posP1 = vector de enteros vacío 	// Almacenar las posiciones de los genes de p1 
			C = vector de enteros de tamaño n inicializado a -1

			Para i $\in$ {0,...,n/2}
				Hacer 
					pos = número aleatorio entero en [0, n)
				Mientras (pos esté en posP1)

				posP1.añadir(pos)
				C[pos] = p1[pos]
			end 

			Para i $\in$ {0,...,n}
				Si C[i] == -1 		// No se le ha asignado gen de p1
					C[i] = p2[i]
				end 
			end 

			Si queda algún cluster vacío en C
				Reparar C
			end

			return C		
		\end{lstlisting}
		\normalsize

		\subparagraph{Operador de cruce por segmento fijo (SF)}
		$ $\\

		\footnotesize 
		\begin{lstlisting}
			Input: primer padre $p1$, segundo padre $p2$, número de genes $n$

			C = vector de enteros de tamaño n
			posP1 = vector de enteros 		// Almacenar las posiciones de los genes de p1 
			r = número aleatorio entero entre [0, n)
			v = número aleatorio entero entre [0, n]

			Para i $\in$ {0,...,v}
				C[r] = p1[r]
				posP1.añadir(r)
				r = (r + 1) % n
			end 

			nIter = n - v			// Iteraciones restantes

			Para i $\in$ {0,...,nIter/2} 
				Hacer 
					pos = número aleatorio entero en [0, n)
				Mientras (pos esté en posP1)

				posP1.añadir(pos)
				C[pos] = p1[pos]
			end 

			Para i $\in$ {0,...,n}
				Si C[i] == -1 		// No se le ha asignado gen de p1
					C[i] = p2[i]
				end 
			end 

			Si queda algún cluster vacío en C
				Reparar C
			end

			return C
		\end{lstlisting}
		\normalsize

		\paragraph{Operador de mutación}
		$ $\\
		Para realizar una mutación, tenemos que tener en cuenta que la probabilidad con la que se produce una mutación de un individuo es de $0.1/numero\_de\_genes$.
		En el caso del AGG, para no tener que elegir números aleatorios en cada iteración, calculamos a priori cuántas mutaciones debe haber, esto es $nMutaciones = probMutacion * m * n$,
		donde $nMutaciones$ es el número de mutaciones, $probMutacion$ es la probabilidad de cruzar, $m$ es el tamaño de la población seleccionada y $n$ es el número de genes.
		Sin embargo, en el AGE no es tan necesario calcularlos a priori, pues el tamaño de la población es $2$, por lo que no habría problema en generar números aleatorios.
		
		\footnotesize 
		\begin{lstlisting}
			Input = probabilidad de mutación $probMutacion$, población $pSiguiente$, tamaño de la población $m$, número de genes $n$

			nMutaciones = 0

			// Calculo cuántas mutaciones se van a realizar
			Si la evolución es AGG 
				nMutaciones = probMutacion * m * n
			Si la evolución es AGE 
				Para i $\in$ {0,...,m}
					prob = número aleatorio entre [0.0, 1.0)

					Si (prob < probMutacion * n)
						Incrementar nMutaciones
					end
				end
			end 

			Para i $\in$ {0,...,nMutaciones}
				pos = número aleatorio entero entre [0, m)
				pSiguiente[pos] = operadorMutacionUN(pSiguiente[pos])
			end

			return pSiguiente
		\end{lstlisting}
		\normalsize

		\subparagraph{Operador de mutación uniforme}
		$ $\\
		\footnotesize 
		\begin{lstlisting}
			Input: cromosoma $C$, número de genes $n$, número de clusters $k$

			Hacer
				posGen = número aleatorio entero en [0, n)
				gen = número aleatorio entero en [0, k)
				C[posGen] = gen
			Mientras quede algún cluster vacío en C

			return C	
		\end{lstlisting}
		\normalsize

		\paragraph{Esquema de reemplazamiento}
		$ $\\

		\footnotesize 
		\begin{lstlisting}
			Input: población actual $pActual$, población siguiente $pSiguiente$, fitness de la población actual $pActualFitness$, 
			tamaño de la población actual $M$, tamaño de la población siguiente $m$, número de evaluaciones fitness $nFitness$
			
			Si la evolución es AGG
				posCMejor = posición de pActualFitness que tenga el menor valor 
				CMejor = pActual[posCMejor]
				fit_min = pActualFitness[posCMejor]
				pActual = pSiguiente 

				Para i $\in$ {0,...,M}
					Evaluar pActualFitness
					Incrementar nFitness
				end 

				Si (CMejor no está en pActual)
					Calcular la posición de pActualFitness que tenga el mayor valor 
					Asignar a pActual en esa posición CMejor 
					Asignar a pActualFitness en esa posicion fit_min
				end
			Si la evolución es AGE 
				Para i $\in$ {0,...,m}
					posCPeor = posición de pActualFitness que tenga el mayor valor
					fit = fitness de pSiguiente[i]
					Incrementar nFitness 

					Si la fitness de posCPeor es mayor que fit
						Asignar a pActual en la posición posCPeor pSiguiente[i] 
						Asignar a pActualFitness la posición posCPeor fit 
					end 
				end 
			end 

			return pActual, pActualFitness
		\end{lstlisting}
		\normalsize

		\paragraph{Implementación de los Algoritmos Genéticos}
		$ $\\
		Al realizar esta práctica, he considerado una única función para implementar todas las variantes de los Algoritmos Genéticos.
		Para ello, en los parámetros de entrada podremos especificar las distintas variantes de estos algoritmos.
		Por lo que el esquema de la implementación general de un algoritmo genético es el siguiente, en el que se hace referencia a las funciones vistas en los apartados anteriores.
		
		\footnotesize 
		\begin{lstlisting}
			Input: tamaño de la población $M$, número de genes $n$, tipo de generación $evolucion$, operador de cruce $operadorCruce$, probabilidad de cruce $probCruce$, número de clusters $k$

			// Inicializar variables con respecto a los parámetros de entrada
			probMutacion = 0.1/n

			// m es el tamaño de la población siguiente
			Si (evolucion == "G")	// generacional
				m = M				
			Si (evolucion == "E")		// estacionario
				m = 2
			end 

			Generar la población inicial aleatoriamente y evaluarla

			nFitnessMAX = 100000
			nFitness = 0		// contador del numero de evaluaciones de la función objetivo 
			t = 0				// número de la generación
			
			Mientras (nFtiness < nFitnessMAX) hacer 
				// SELECCIONAR
				pSiguiente = operador de selección

				// CRUZAR 
				nCruces = probCruce *m/2.0
				pSiguiente = operador de cruce (operadorCruce, nCruces)

				// MUTAR 
				pSiguiente = operador de mutación

				// REEMPLAZAR Y EVALUAR
				pActual,pActualFitness = esquema de reemplazamiento

				Incrementar t
			end

			// Actualizamos los atributos con la solución
			posCMejor = posición de pActualFitness que tenga el menor valor
			clusters = pActual[posCMejor]
			desvGeneral = desviacionGeneral(pActual[posCMejor])
			fitness = fitness(pActual[posCMejor])
			infeasibility = infeasibility(pActual[posCMejor])

			return clusters
		\end{lstlisting}
		\normalsize

		\subsubsection{Algoritmos Meméticos (AM)}
		$ $\\
		Los algoritmos meméticos implementados se basan en un algoritmo genético generacional, pero cada un cierto número de generaciones 
		se le aplica una búsqueda local a un cierto número de cromosomas que conforman la población.

		Así, con el algoritmo genético generacional podremos explorar nuevas zonas del espacio y, con la búsqueda local, podremos minimizar la función objetivo 
		de ciertos cromosomas, pues encontraremos mínimos locales.
		
		El algoritmo genético generacional escogido para implementar el algoritmo memético es el que usa el operador de cruce uniforme, pues da mejores resultados que el de por segmento fijo.
		El esquema de evolución de este algoritmo es similar al algoritmo genético generacional, salvo que después de la mutación y cada 10 generaciones se le aplica la búsqueda local a un cierto número de cromosomas.
		Esta búsqueda local no es la misma que la búsqueda local implementada en la práctica 1, sino que es más suave. Esto se debe a que la búsqueda local de la práctica 1 hacía que las soluciones 
		convergieran demasiado rápido. De esta forma, la búsqueda local suave solo recorrerá cada cromosoma una sola vez y tendremos en cuenta el número de fallos (cuando la BLS no produce cambios en el cromosoma), pues este no podrá superar un cierto límite.
		
		En cuanto a los valores de los parámetros, se establece el número de fallos máximo permitido es $nFallosMAX = 0.1 * n$, donde $n$ es el número de genes de cada cromosoma de la población.
		Al igual que en los algoritmos genéticos, el tamaño de la población será de $50$ cromosomas, la probabilidad de cruce será de $0.7$ por cromosoma, la probabilidad de mutación será de $0.1/numero\_de\_genes$ por gen y 
		el criterio de parada será de relizar $100000$ evaluaciones de la función objetivo.

		En esta práctica se han implementado los tres siguientes Algoritmos Meméticos.

		\begin{itemize}
			\item \textbf{AM-(10, 1.0)}: la búsqueda local suave se aplica sobre todos los cromosomas de la población cada $10$ generaciones.
			\item \textbf{AM-(10, 0.1)}: la búsqueda local suave se aplica sobre un subconjunto de cromosomas de la población seleccionado aleatoriamente con una probabilidad de $0.1$ para cada cromosoma cada $10$ generaciones.
			\item \textbf{AM-(10, 0.1mej)}: la búsqueda local suave se aplica sobre los $0.1*M$ mejores cromosomas de la población actual ($M$ es el tamaño de esta) cada $10$ generaciones.
		\end{itemize}
\newpage
		\paragraph{Esquema de reemplazamiento}
		$ $\\
		He realizado algunos cambios con respecto al esquema de reemplazamiento de los Algoritmos Genéticos.

		\footnotesize 
		\begin{lstlisting}
			Input: población actual $pActual$, población siguiente $pSiguiente$, fitness de la población actual $pActualFitness$, 
			fitness de la población siguiente $pSigFitness$

			posCMejor = posición de pActualFitness que tenga el menor valor 
			CMejor = pActual[posCMejor]
			fit_min = pActualFitness[posCMejor]
			pActual = pSiguiente 
			pActualFitness = pSigFitness

			Si (CMejor no está en pActual)
				Calcular la posición de pActualFitness que tenga el mayor valor 
				Asignar a pActual en esa posición CMejor 
				Asignar a pActualFitness en esa posicion fit_min
			end

			return pActual, pActualFitness
		\end{lstlisting}
		\normalsize

		\paragraph{Esquema de búsqueda}
		$ $\\
		El esquema de búsqueda se sitúa después de la fase de mutación, pero antes de la fase de reemplazamiento.
		
		\footnotesize 
		\begin{lstlisting}
			Input: población siguiente $pSiguiente$, fitness de la población siguiente $pSigFitness$, tamaño de la población actual $M$, número de evaluaciones fitness $nFitness$, número de generación $t$, hibridación, probabilidad de selección $probSeleccion$

			Si t es múltiplo de 10
				Si la hibridación no es AM-(10, 0.1mej)
					Para i $\in$ {0,...,M}
						Si probSeleccion es 1.0 or randfloat(0.0, 1.0) < probSeleccion 
							nFitness += BLS (pSiguiente[i], pSigFitness[i], nFallos) 	// dos primeros parámetros pasados por referencia
						end
					end
				Si la hibridación es AM-(10, 0.1mej)
					m = 0.1*M
					// Ordenar de menor a mayor
					Para i $\in$ {1,...,M}
						Para j $\in$ {0,...,M-i}
							Si (pSigFitness[j] > pSigFitness[j+1])
								Intercambiar los valores de pSigFitness[j] y pSigFitness[j+1]
								Intercambiar los valores de pSiguiente[j] y pSiguiente[j+1]
							end 
						end 
					end
					Para i $\in$ {1,...,m}
						nFitness += BLS (pSiguiente[i], pSigFitness[i], nFallos) 	// dos primeros parámetros pasados por referencia
					end
				end
			end 

			return pSiguiente, pSigFitness
		\end{lstlisting}
		\normalsize

		\paragraph{Búsqueda Local Suave}
		$ $\\
		\footnotesize 
		\begin{lstlisting}
			Input: cromosoma (solución) $S$, fitness del cromosoma $S$ $fitnessActual$, número de fallos máximo $nFallosMAX$, número de clusters $k$

			n = S.size() 		// número de genes
			nFallos = 0
			i = 0
			mejora = true 
			fit_min = fitnessActual
			indicesDatos = vector de enteros vacío

			Para i $\in$ {0,...,n}
				indicesDatos.añadir(i)
			
			RSI <- RandomShuffle(indicesDatos)	//Barajar los índices a los datos

			Mientras ((mejora or nFallos < nFallosMAX) and i < n)
				mejora = false

				Para j $\in$ {0,...k}
					$c_i$ = S[RSI[i]] 		// Cluster asociado a la instancia RSI[i]
					par <- ($c_i$, j) 		// Par formado por el cluster actual y el cluster j

					// Comprobamos que no sean iguales y que el par sea válido (esto es, que no deje ningún cluster vacío al realizar cambiar el cluster $c_i$ por j)
					Si ($c_i$ != j and parValido(par, S)) 
						S[RSI[i]] = j		// Asociamos el cluster j a la instancia RSI[i]
						fit = fitness(S)
						Incrementar nEvaluaciones

						Si (fit < fit_min)	// Si mejora la función objetivo, actualizamos
							fit_min = fit 
							mejora = true 
						Si no				// Si no mejora la función objetivo, asignamos el cluster anterior 
							S[RSI[i]] = $c_i$
						end 
					end 
				end 

				Si (no hay mejora)
					Incrementar nFallos 
				end 

				Incrementar i
			end

			return nEvaluaciones, S, fitnessActual	// S y fitnessActual se devuelven por referencia
		\end{lstlisting}
		\normalsize

		\paragraph{Implementación de los Algoritmos Meméticos}
		$ $\\
		Al realizar esta práctica, he considerado una única función para implementar todas las variantes de los Algoritmos Meméticos.
		Para ello, en los parámetros de entrada podremos especificar las distintas variantes de estos algoritmos.
		Por lo que el esquema de la implementación general de un algoritmo memético es el siguiente, en el que se hace referencia a las funciones vistas en los apartados anteriores.
		
		\footnotesize 
		\begin{lstlisting}
			Input: tamaño de la población $M$, número de genes $n$, tipo de hibridación $hibridacion$, probabilidad de cruce $probCruce$, número de clusters $k$

			// Inicializar variables con respecto a los parámetros de entrada
			probMutacion = 0.1/n
			nMutaciones = probMutacion * M * n
			nFallos = 0.1*n
			prob = 0

			// m es el tamaño de la población a aplicarle BLS
			Si (hibridacion == "1.0")
				probSeleccion = 1.0
				m = M		
				mejor = false		
			Si (hibridacion == "0.1")
				probSeleccion = 0.1
				m = probSeleccion * M
				mejor = false
			Si (hibridacion == "0.1mej")
				probSeleccion = 0.1
				m = probSeleccion * M
				mejor = true
			end 

			Generar la población inicial aleatoriamente y evaluarla

			nFitnessMAX = 100000
			nFitness = 0		// contador del numero de evaluaciones de la función objetivo 
			t = 1				// número de la generación
			
			Mientras (nFtiness < nFitnessMAX) hacer 
				// SELECCIONAR
				pSiguiente = operador de selección

				// CRUZAR 
				nCruces = probCruce *m/2.0
				pSiguiente = operador de cruce uniforme

				// MUTAR 
				pSiguiente = operador de mutación

				// BLS
				// Evaluar la nueva población
				Para i $\in$ {0,...M}
					pSigFitness = fitness(pSiguiente[i])
					Incrementar nFitness
				end 

				Si (t es múltiplo de 10)
					pSiguiente, pSigFitness = esquema de búsqueda
				end

				// REEMPLAZAR Y EVALUAR
				pActual = esquema de reemplazamiento

				Incrementar t
			end

			// Actualizamos los atributos con la solución
			posCMejor = posición de pActualFitness que tenga el menor valor
			clusters = pActual[posCMejor]
			desvGeneral = desviacionGeneral(pActual[posCMejor])
			fitness = fitness(pActual[posCMejor])
			infeasibility = infeasibility(pActual[posCMejor])

			return clusters
		\end{lstlisting}
		\normalsize
\newpage

\section{Pseudocódigo de los algoritmos de comparación}
		En la práctica 1, he implementado el algoritmo \textbf{Greedy COPKM} para compararlo con el otro algoritmo de la práctica 1 (BL).
		Este algoritmo se basa en el algoritmo k-medias para agrupar un conjunto de datos con la diferencia de que tiene en cuenta 
		las restricciones asociadas a dicho conjunto.

		Al contrario que la Búsqueda Local, este algoritmo intenta minimizar el número de restricciones incumplidas aunque la desviación general 
		sea mayor.

		\subsection{Generación de centroides aleatorios}
		Este algoritmo comienza generando unos centroides aleatorios con valores en el dominio de los datos.

		\footnotesize
		\begin{lstlisting}
		Input: dimensión del conjunto de datos $n$, número de clusters $k$, centroides {$\mu _1 , ..., \mu _k$}
		
		Borrar el contenido de los centroides

		for i $\in$ {0,...,k-1} do 
			Asignar al centroide $\mu _i$ un vector de dimensión $n$ con valores aleatorios entre 0 y 1
		end
		\end{lstlisting}
		\normalsize

		\subsection{Pseudocódigo para actualizar los centroides}
		En este algoritmo es necesario que se actualicen los centroides cada vez que se produzca un cambio en los clusters.

		\footnotesize
		\begin{lstlisting}
		Input: índices a los clusters {$l_1,...,l_n$}

		Comprobar que todos los elementos estén asociados a un cluster

		// Calcular el número de elementos de cada cluster
		for i $\in$ {0,...,n-1} do 
			Incrementar el contador de cluster al que pertenece $l_i$
		end 

		Inicializar los centroides a 0

		// Promediar las instancias asociadas a cada cluster
		for i $\in$ {0,...,n-1} do
			Sumar las coordenadas de los datos que pertenecen al cluster $l_i$ en su centroide $\mu _{l_i}$
		end
		
		for i $\in$ {0,...,k-1} do
			Asignar al centroide $\mu _i$ la división del centroide $\mu _i$ entre el número de elementos del cluster $c_i$
		end
		\end{lstlisting}
		\normalsize

		\subsection{Pseudocódigo del algoritmo Greedy}
		Una vez inicializados los centroides, barajamos los datos para recorrerlos aleatoriamente y en cada iteración, asignamos 
		cada dato al cluster en el que menos restricciones incumple y al que menor distancia de encuentra.

		\footnotesize
		\begin{lstlisting}
		Input: conjunto de datos X

		Inicializar centroides aleatoriamente
		
		//Barajar los índices a los datos 
		RSI <- RandomShuffle({0,...,n-1})

		do 
			for i $\in$ RSI do 
				for j $\in$ {0,...,k-1} do 
					Calcular el número de restricciones que incumple el dato $x_i$ en el cluster $j$

					Si (el número de restricciones incumplidas es menor que el actual) do
						Guardar el número de restricciones incumplidas, el cluster y la distancia actuales por los nuevos valores
					Si (el número de restricciones incumplidas es igual que el actual) do 
						Si (la distancia del dato $x_i$ al cluster $j$ es menor que la distancia actual) do 
							Guardar el cluster y la distancia actuales por los nuevos valores
						end
					end
				end 

				Si (el cluster asignado a $x_i$ ha sido modificado) do 
					Actualizar el cluster asignado a $x_i$ por el nuevo valor
				end
			end

			Actualizar los centroides
		while Haya cambios en algún cluster

		// Comprobar que no ha quedado algún cluster vacío
		Si (no hay algún cluster vacío) do 
			Actualizar la desviación general, fitness e infeasibility
			Devolver la lista de clusters
		Si no
			Volver a ejecutar Greedy 
		end
		\end{lstlisting}
		\normalsize
\newpage

\section{Procedimiento considerado para desarrollar la práctica}
	\subsection{Implementación a partir del código proporcionado en prácticas o a partir de cualquier otro}
	Para el desarrollo de mi práctica he necesitado generar números aleatorios, para ello he utilizado el código 
	proporcionado por los profesores que se encuentra en los archivo \lstinline!random.h! y \lstinline!random.cpp!.
	
	Además, para medir el tiempo he usado la librería \lstinline!chrono!.

	Para implementar la clase \lstinline!PAR! he usado la STL de C++ (\lstinline!vector! y \lstinline!pair!), la librería \lstinline!math!, etc.

	\subsection{Manual de usuario}
		\subsubsection{Estructura de carpetas}
			La organización de esta práctica se ha dividido en varias carpetas.
			
			\begin{itemize}
				\item \textbf{\lstinline!BIN/!}: carpeta que contiene el ejecutable.
				\item \textbf{\lstinline!BIN/DATA/!}: carpeta que contiene el conjunto de datos y sus restricciones.
				Al ejecutar la práctica, creará los archivos con los resultados de cada algoritmo.
				\item \textbf{\lstinline!FUENTES/include/!}: carpeta que contiene los archivos de cabecera.
				\item \textbf{\lstinline!FUENTES/src/!}: carpeta que contiene los archivos fuente.
				\item \textbf{\lstinline!FUENTES/obj/!}: carpeta que contiene los archivos objeto.
			\end{itemize}

		\subsubsection{Compilación}
			Para compilar la práctica, he creado un fichero \lstinline!Makefile!. Por lo que bastará con ejecutar el siguiente comando
		
		\footnotesize
		\begin{lstlisting}
		make
		\end{lstlisting}
		\normalsize

			Nos creará en la carpeta \lstinline!BIN/! un ejecutable llamado \lstinline!practica1!.

		\subsubsection{Ejecución}
			Para ejecutar la práctica, necesitamos pasarle al ejecutable los siguientes parámetros.

		\footnotesize
		\begin{lstlisting}
		./BIN/practica1 ficheroDatos.dat ficheroRestricciones.const 
		númeroDeClusters semilla
		\end{lstlisting}
		\normalsize

			Por ejemplo, si queremos ejecutar la práctica con los datos de \lstinline!zoo! con el $10$\% de restricciones con la semilla $22$,
			tendremos que hacer lo siguiente.

		\footnotesize
		\begin{lstlisting}
		./BIN/practica1 zoo_set.dat zoo_set_const_10.const 7 22 
		\end{lstlisting}
		\normalsize

			En la terminal veremos qué algoritmos se están ejecutando y, una vez terminen, mostrarán un mensaje con la ruta donde se encuentra 
			el fichero con los resultados.
\newpage

\section{Experimentos y análisis de resultados}


\subsection{Casos del problema empleados y valores de los parámetros considerados en las ejecuciones de cada algoritmo}

\subsubsection{Casos del problema empleados}

Para realizar esta práctica, he considerado tres conjuntos de datos:

\begin{enumerate}
	\item \textbf{Zoo:} contiene los datos de un conjunto de animales, cada uno con 16 atributos sobre sus características. 
	El objetivo es clasificar 101 instancias de animales en 7 clases según sus atributos.
	\item \textbf{Glass:} contiene los datos de un conjunto de vidrios, cada uno con 5 atributos sobre sus componentes químicos.
	El objetivo es clasificar 214 instancias de vidrios en 7 clases según sus atributos.
	\item \textbf{Bupa:} contiene los datos de un conjunto de personas, cada una con 5 atributos sobre sus hábitos de consumo de alcohol.
	El objetivo es clasificar 345 instancias de personas en 16 clases según sus atributos.
\end{enumerate}

Cada conjunto de datos tiene asociados dos conjuntos de restricciones, correspondientes al 10\% y al 20\% 
del total de restricciones posibles. Estas restricciones serán muy importantes a la hora de determinar una solución,
pues indican qué conjuntos de datos son los que deben ir en la misma clase, aunque parezcan muy distintos, y los que deban ir a clases distintas, aunque parezcan ser similares.
Los algoritmos tendrán en cuenta estas restricciones para agrupar las instancias.

En total, el PAR trabajará con 6 instancias generadas a partir de los datos anteriores.

\subsubsection{Valores de los parámetros considerados}

Para determinar si los algoritmos funcionan correctamente, necesitamos ejecutarlos de formas diferentes. Para ello, inicializamos 
una semilla y a partir de esta, los algoritmos tomarán secuencias distintas aleatorias y, por ello, resultados diferentes.
Para realizar las ejecuciones, he elegido las siguientes cinco semillas de forma aleatoria: $7$, $22$, $100$, $222$, $273687$.
Por lo que para cada semilla, conjunto de datos y conjunto de restricciones, he realizado una ejecución. Así, he realizado $30$ ejecuciones en total por algoritmo.

\subsection{Resultados obtenidos}

A continuación se muestran los resultados obtenidos con los distintos algoritmos y las medias.

\subsubsection{Algoritmo Genético Generacional con operador de cruce uniforme (AGG-UN)}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGG-UN en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 7 & 0.616729 & 0.669773 & 0.932 & 			94 & 0.21078 & 0.30328 & 3.856 &			 	642 & 0.161176 & 0.338852 & 9.771 		\\ \hline
	22 		& 3 & 0.696395 & 0.719128 &	0.906 &			117 & 0.291395 & 0.406528 &	3.782 &		 	623 & 0.172427 & 0.339384 &	9.194		\\ \hline
	100 	& 7 & 0.756588 & 0.809631 &	0.902 &			34 & 0.258035 & 0.291492 & 	3.745 &			517 & 0.162132 & 0.300682 &	9.289		\\ \hline
	222 	& 9 & 0.618185 & 0.686383 & 0.908 &			45 & 0.224313 & 0.268595 & 	3.584 &			647 & 0.165722 & 0.33911 &	9.172		\\ \hline
	273687 	& 9 & 0.610618 & 0.678817 & 0.911 & 			58 & 0.235553 & 0.292627 & 	3.570 &			630 & 0.163313 & 0.332146 &	9.174		\\ \hline
	\textbf{Media} &  7 & 	0.659642 & 	0.7633408 & 	0.9118000 & 	69.6 & 	0.2440152 & 	0.3125044 & 	3.7074000 & 	611.8 & 	0.1649540 & 	0.3300348 & 	9.3200000   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGG-UN en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 10 & 0.733622 & 0.774003 & 1.026 & 			94 & 0.24375 & 0.292687 & 4.807 &			 	1271 & 0.170463 & 0.347692 & 13.631 		\\ \hline
	22 		& 16 & 0.800919 & 0.865528 &	0.973 &			99 & 0.209938 & 0.280197 &	4.721 &		 	1330 & 0.166984 & 0.35244 &	12.913		\\ \hline
	100 	& 23 & 0.712827 & 0.805703 &	0.974 &			126 & 0.200623 & 0.26622 & 	4.769 &			1236 & 0.157651 & 0.33 &	13.572		\\ \hline
	222 	& 36 & 0.61315 & 0.758521 & 0.971 &				122 & 0.261986 & 0.3255 & 	4.684 &			1181 & 0.157295 & 0.321975 &	12.918		\\ \hline
	273687 	& 13 & 0.710965 & 0.76346 & 0.973 & 			114 & 0.214026 & 0.273376 &  4.703 &			1095 & 0.159297 & 0.311985 &	12.899		\\ \hline
	\textbf{Media} &  19.6 & 	0.7142966 & 	0.7934430 & 	0.9834000 & 	111.0 & 	0.2266004 & 	0.2804316 & 	4.7368000 & 	1222.6	 & 0.1623380 & 	0.3328184 & 	13.1866000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

Como podemos observar, en ambos casos obtenemos unos resultados muy similares.

En cuanto al \textbf{número de restricciones incumplidas}, tenemos que son un poco más elevadas con el 20\% de restricciones (el doble aproximadamente). Además, 
en el conjunto de datos de Zoo esta medida es bastante menor en comparación con la tasa que tiene Bupa. Aunque esto último tiene sentido, pues Bupa tiene mayor número de restricciones máximas.

Con respecto a la \textbf{desviación general}, las diferencias apenas se notan al cambiar el número de restricciones. Aunque hay que observar que 
entre los conjuntos de datos, esta medida es mucho menor en el conjunto de datos Bupa que en Zoo, esto quiere decir que los datos están más cerca del centroide en Bupa que en Zoo.
El conjunto de datos Glass también tiene una desviación general pequeña, aunque un poco mayor que Bupa.

Con respecto al \textbf{agregado}, la función objetivo, también obtenemos resultados muy similares cuando pasamos de considerar 10\% de restricciones a 20\% de restricciones, aunque en el caso de Glass disminuye un poco.
Si comparamos entre los conjuntos de datos, ocurre lo mismo que con la desviación general, Zoo tiene un agregado mayor que Bupa. Sin embargo, Glass consigue obtener menor agregado que Bupa, aunque no hay gran diferencia.

También hay que destacar el \textbf{tiempo} (medido en segundos). Conforme aumentamos el número de instancias de nuestro conjunto de datos, el tiempo aumenta notablemente. Esto es, en Zoo con 101 instancias el algoritmo apenas tarda 1 segundo en obtener el resultado; 
pero en Bupa con 345 instancias, el tiempo aumenta considerablemente hasta los 9 segundos y 13 segundos, con el 10\% y 20\% de restricciones respectivamente.

\subsubsection{Algoritmo Genético Generacional con operador de cruce de segmento fijo (AGG-SF)}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGG-SF en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 6 & 0.621439 & 0.666904 & 1.001 & 				48 & 0.207558 & 0.254792 & 3.952 &			 	664 & 0.174835 & 0.352779 & 9.791 		\\ \hline
	22 		& 25 & 0.747291 & 0.936732 & 0.957 &				115 & 0.249864 & 0.363029 &	3.927 &		 	664 & 0.162338 & 0.340282 &	9.510		\\ \hline
	100 	& 16 & 0.604719 & 0.725961 & 0.956 &				43 & 0.241458 & 0.283772 & 3.856 &				649 & 0.168756 & 0.34268 & 9.435			\\ \hline
	222 	& 7 & 0.599621 & 0.652665 &	0.959 &				165 & 0.300234 & 0.462601 & 3.697 &			614 & 0.168778 & 0.333322 &	9.526		\\ \hline
	273687 	& 12 & 0.606473 & 0.697405 & 0.961 &				68 & 0.258702 & 0.325617 & 3.693 &				674 & 0.169531 & 0.350155 &	9.602		\\ \hline
	\textbf{Media} & 13.2 & 	0.6359086 & 	0.7359334 & 	0.9668000 & 	87.8 & 	0.2515632 & 	0.3379622 & 	3.8250000 & 	653.0 & 	0.1688476 & 	0.3438436 & 	9.6328000   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGG-SF en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 18 & 0.667604 & 0.74029 & 1.083 & 				96 & 0.24029 & 0.290268 & 4.864 &			 	1284 & 0.153488 & 0.332531 & 12.948 		\\ \hline
	22 		& 9 & 0.754158 & 0.790501 & 1.028 &				116 & 0.20881 & 0.269201 & 4.848 &		 	1135 & 0.170115 & 0.328381 &	12.186		\\ \hline
	100 	& 26 & 0.705901 & 0.810891 & 1.022 &				 68 & 0.236814 & 0.272215 & 4.801 &				1272 & 0.159274 & 0.336643 & 12.583			\\ \hline
	222 	& 62 & 0.871068 & 1.12143 &	1.019 &				78 & 0.256109 & 0.296716 & 4.866 &			1263 & 0.161611 & 0.337725 &	12.114		\\ \hline
	273687 	& 21 & 0.693301 & 0.778101 & 1.030 &				108 & 0.258661 & 0.314887 & 4.806 &				1130 & 0.163048 & 0.320616 &	12.120		\\ \hline
	\textbf{Media} &  27.2 & 	0.7384064 & 	0.8482426 & 	1.0364000 & 	93.2 & 	0.2401368 & 	0.2886574 & 	4.8370000 & 	1216.8	 & 0.1615072 & 	0.3311792	 & 12.3902000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

En este caso volvemos a tener las mismas conclusiones que con el operador de cruce uniforme.

Al pasar del 10\% de restricciones al 20\% de restricciones, en Zoo aumenta el número de restricciones incumplidas, la desviación general, el agregado y el tiempo (aunque en este último no se aprecia gran diferencia).
Este conjunto de datos sigue obtieniendo las peores medidas entre los tres.

Con respecto al Glass, el número de restricciones incumplidas es más similar, al igual que la desviación general y el agregado, aunque estos últimos disminuyen al considerar el 20\% de restricciones.
Este conjunto de datos obtiene el menor agregado entre los tres conjuntos de datos considerados.

Con respecto al Bupa, el número de restricciones incumplidas es casi el doble al pasar de considerar el 10\% al 20\% de restricciones. Sin embargo, la desviación general y el agregado se mantienen similares. 
Además, obtiene la menor desviación general de entre los conjuntos de datos considerados.

\subsubsection{Algoritmo Genético Estacionario con operador de cruce uniforme (AGE-UN)}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGE-UN en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 6 & 0.624073 & 0.669538 & 1.022 &  				53 & 0.209767 & 0.261921 & 4.035 &			 	527 & 0.151924 & 0.293154 & 9.792 		\\ \hline
	22 		& 3 & 0.679621 & 0.702354 &	0.979 & 				46 & 0.250655 & 0.295921 & 4.013	&		 	554 & 0.163209 & 0.311674 &	9.617		\\ \hline
	100 	& 21 & 0.71289 & 0.87202 &	0.979 & 				48 & 0.258733 & 0.305967 & 	3.959	&		604 & 0.155568 & 0.317433 &	9.582		\\ \hline
	222 	& 19 & 0.773927 & 0.917902 & 0.982 &				65 & 0.225725 & 0.289688 & 3.786	 &			553 & 0.142867 & 0.291064 &	9.554		\\ \hline
	273687 	& 20 & 0.565396 & 0.716948 &	0.980 &				94 & 0.267731 & 0.360231 & 	3.780		&	605 & 0.168274 & 0.330407 &	9.721		\\ \hline
	\textbf{Media} &  13.8 & 	0.671152 & 	0.7799214 & 	0.9884000 & 	61.2 & 	0.2425222 & 	0.3027456 & 	3.9146000 & 	568.6 & 	0.1563684 & 	0.3087464 & 	9.5332000   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGE-UN en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 19 & 0.730876 & 0.807599 & 1.119 &  				62 & 0.241121 & 0.273399 & 4.966 &			 	1026 & 0.154744 & 0.29781 & 12.011 		\\ \hline
	22 		& 38 & 0.61912 & 0.772567 &	1.049 & 				28 & 0.237202 & 0.251779 & 5.044	&		 		1102 & 0.166333 & 0.319997 &	12.300		\\ \hline
	100 	& 37 & 0.591113 & 0.740522 &	1.104 & 			196 & 0.221104 & 0.323144 & 4.921 &				994 & 0.143613 & 0.282218 &	12.526		\\ \hline
	222 	& 11 & 0.777527 & 0.821946 & 1.054 &				131 & 0.195658 & 0.263858 & 4.915 &				1048 & 0.143829 & 0.289963 &	12.251		\\ \hline
	273687 	& 12 & 0.718619 & 0.767076 &	1.060 &				82 & 0.270145 & 0.312835 & 	4.914&				1122 & 0.148791 & 0.305244 &	12.226		\\ \hline
	\textbf{Media} &  23.4 & 	0.6874510 & 	0.7819420 & 	1.0772000 & 	99.8 & 	0.2308080 & 	0.2852010 & 	4.9615000	 & 1058.4 & 	0.1514614 & 	0.299041 & 	12.4628   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

Podemos observar que los resultados, salvo el número de restricciones incumplidas, se mantienen prácticamente iguales al considerar el 10\% de restricciones o el 20\% de restricciones.
Además, sigue ocurriendo lo ya comentado anteriormente. Seguimos obteniendo resultados más bajos en la función objetivo con el conjunto de datos Glass, aunque los resultados de Bupa son también muy similares.

\subsubsection{Algoritmo Genético Estacionario con operador de cruce de segmento fijo (AGE-SF)}


\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGE-SF en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 17 & 0.851007 & 0.979827 & 1.108 &				31 & 0.240894 & 0.2714 & 4.185 &			 	454 & 0.173861 & 0.295527 &  9.534		\\ \hline
	22 		& 8 & 0.594655 & 0.655277 &	1.053 &				64 & 0.204385 & 0.267364 &	4.174 &		 	596 & 0.165332 & 0.325053 &	9.891		\\ \hline
	100 	& 5 & 0.656766 & 0.694654 &	1.053 &				39 & 0.255808 & 0.294186 & 4.158 &				536 & 0.163286 & 0.306928 &	9.832		\\ \hline
	222 	& 3 & 0.698947 & 0.721679 &	1.051 &				55 & 0.221483 & 0.275605 &	4.000 & 			621 & 0.14771 & 0.31413 & 9.978			\\ \hline
	273687 	& 7 & 0.611213 & 0.664256 &	1.058 &				96 & 0.281656 & 0.376123 &	3.928 &			546 & 0.154073 & 0.300394 &	9.778		\\ \hline
	\textbf{Media} &  8.0 & 	0.6825176 & 	0.7431386 & 	1.0646000 & 	57.0 & 	0.2408452 & 	0.2969356 & 	4.0890000 & 	550.6 & 	0.1608524 & 	0.3084064 & 	9.8626000   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AGE-SF en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 23 & 0.713615 & 0.806491 & 1.196 &				58 & 0.247927 & 0.278122 & 5.076 &			 	1082 & 0.157517 & 0.308392 &  12.364		\\ \hline
	22 		& 31 & 0.586849 & 0.712029 &	1.117 &				33 & 0.250079 & 0.267259 &	5.107 &		 	1113 & 0.15694 & 0.312137 & 12.428		\\ \hline
	100 	& 11 & 0.716085 & 0.760504 &	1.117 &				119 & 0.234565 & 0.296518 & 5.040 &				1063 & 0.153892 & 0.302118 &	12.814		\\ \hline
	222 	& 20 & 0.720629 & 0.801391 &	1.125 &				48 & 0.241654 & 0.266643 &	5.030 & 			1148 & 0.143141 & 0.303219 & 11.398			\\ \hline
	273687 	& 11 & 0.761687 & 0.806106 &	1.122 &				64 & 0.246541 & 0.27986 &	5.044 &			992 & 0.151156 & 0.289482 &	12.462		\\ \hline
	\textbf{Media} &  19.2 & 	0.6997730	 & 0.7773042 & 	1.1354000 & 	64.4	 & 0.2441532 & 	0.2776804 & 	5.0594000 & 	1079.6 & 	0.1525292 & 	0.3030696 & 	12.69320 \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

Seguimos obteniendo unos resultados mucho más similares considerando el 10\% o el 20\% de restricciones y tampoco hay cambios entre lo ya comentado.

\subsubsection{Algoritmo Memético (AM(10, 1.0))}


\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 1.0) en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 21 & 0.735185 & 0.894316 & 0.890 &				153 & 0.237252 & 0.38781 & 3.745 &			 	768 & 0.217242 & 0.423057 & 14.162		\\ \hline
	22 		& 22 & 0.730314 & 0.897022 & 0.915 &				140 & 0.2593 & 0.397066 & 3.709 &		 	725 & 0.214201 & 0.408492 & 14.994		\\ \hline
	100 	& 8 & 0.607626 & 0.668247 & 0.913 &				76 & 0.283497 & 0.358284 & 3.721 &				732 & 0.216566 & 0.412733 & 14.791		\\ \hline
	222 	& 10 & 0.61995 & 0.695727 & 0.935 &				32 & 0.228566 & 0.260056 & 3.840 & 			632 & 0.217278 & 0.386646 & 14.797			\\ \hline
	273687 	& 7 & 0.609378 & 0.662422 & 0.883 &				223 & 0.267884 & 0.487325 & 3.889 &			737 & 0.217196 & 0.414703 & 14.184		\\ \hline
	\textbf{Media} &  13.6 & 	0.6604906 & 	0.7635468 & 	0.9072000 & 	124.8 & 	0.2552998 & 	0.3781082 & 	3.7808000 & 	718.8 & 	0.2164966 & 	0.4091262 & 	14.7856000   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 1.0) en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 16 & 0.704467 & 0.769077 & 1.045 &				108 & 0.198405 & 0.254631 & 5.064 &			 	1332 & 0.194935 & 0.380671 & 22.165		\\ \hline
	22 		& 12 & 0.754505 & 0.802962 & 1.086 &				77 & 0.242111 & 0.282198 & 4.927 &		 	1482 & 0.209528 & 0.41618 & 21.351		\\ \hline
	100 	& 12 & 0.704538 & 0.752995 & 1.099 &				117 & 0.228453 & 0.289365 & 4.902 &				1522 & 0.213668 & 0.425897 & 22.295		\\ \hline
	222 	& 12 & 0.71877 & 0.767226 & 1.090 &				85 & 0.239904 & 0.284156 & 4.886 & 			1316 & 0.20384 & 0.387344 & 22.417			\\ \hline
	273687 	& 17 & 0.712827 & 0.781474 & 1.073 &				101 & 0.219622 & 0.272203 & 5.022 &			 1176 & 0.190346 & 0.354329 & 21.547		\\ \hline
	\textbf{Media} &  12.8 & 	0.7215220 & 	0.7687846	 & 1.0786000 & 	97.6 & 	0.225696 & 	0.27651 & 	4.9602 & 	1365.6	 & 0.2024634 & 	0.3928842 & 	21.95500   \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

En cuanto al numero de restricciones incumplidas, observamos que en Zoo y en Glass disminuyen al considerar el 20\% de las restricciones en comparación con el 10\% de las restricciones.
Sin embargo, la desviación general y el agregado en Zoo aumentan un poco, pero en Glass disminuyen. En cuanto al tiempo empleado en estos dos conjuntos de datos, apenas hay diferencias.
Con respecto al conjunto de datos Bupa, el número de restricciones incumplidas sigue aumentando considerablemente al considerar el 10\% y 20\% de las restricciones. Sin embargo, la desviación general y el agregado 
se mantienen similares, incluso llegan a disminuir un poco al considerar el 20\% de las restricciones. Aunque la diferencia entre los tiempos es bastante grande.

Seguimos obteniendo que Glass obtiene menores resultados en la función objetivo.


\subsubsection{Algoritmo Memético (AM(10, 0.1))}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 0.1) en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 20 & 0.80683 & 0.958383 & 0.953 &				56 & 0.186887 & 0.241993 & 3.774 &			 	240 & 0.149366 & 0.213683 & 9.329		\\ \hline
	22 		& 6 & 0.605297 & 0.650763 & 0.971 &				27 & 0.233863 & 0.260432 & 3.867 &		 	249 & 0.140293 & 0.207022 & 9.173		\\ \hline
	100 	& 2 & 0.70367 & 0.718825 & 0.983 &				47 & 0.195301 & 0.241551 & 3.851 &				242 & 0.129072 & 0.193925 & 9.256		\\ \hline
	222 	& 15 & 0.717589 & 0.831254 & 0.977 &				14 & 0.189513 & 0.241667 & 3.829 & 			157 & 0.145561 & 0.187635 & 9.041		\\ \hline
	273687 	& 17 & 0.829324 & 0.958144 & 0.976 &				56 & 0.189351 & 0.244457 & 3.855 &			244 & 0.132694 & 0.198083 & 9.287		\\ \hline
	\textbf{Media} &  12.0 & 	0.7325420 & 	0.8234738 & 	0.9720000 & 	42.8 & 	0.1989830 & 	0.2460200 & 	3.8352000 & 	226.4 & 	0.1393972 & 	0.2000696 & 	9.2172000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 0.1) en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 15 & 0.69809 & 0.758661 & 1.121 &				42 & 0.250108 & 0.271974 & 5.426 &			 	423 & 0.143491 & 0.192897 & 12.540		\\ \hline
	22 		& 14 & 0.709731 & 0.758188 & 1.155 &				29 & 0.24928 & 0.264377 & 5.449 &		 	449 & 0.138578 & 0.194369 & 12.448		\\ \hline
	100 	& 16 & 0.71792 & 0.78253 & 1.129 &				94 & 0.194802 & 0.260399 & 5.488 &				270 & 0.130711 & 0.16836 & 12.594		\\ \hline
	222 	& 16 & 0.724873 & 0.789483 & 1.150 &				101 & 0.206209 & 0.25879 & 5.407 & 			451 & 0.134871 & 0.197758 & 12.570			\\ \hline
	273687 	& 19 & 0.703637 & 0.780361 & 1.135 &				121 & 0.201137 & 0.26413 & 5.426 &			378 & 0.138892 & 0.191601 & 12.022		\\ \hline
	\textbf{Media} &  16.0 & 	0.701556	 & 0.7678202	 & 1.1380000	 & 83.8 & 	0.2203072 & 	0.2639340 & 	5.4392000 & 	394.2	 & 0.1373086 & 	0.1902760 & 	12.4348000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

Seguimos obteniendo resultados muy parecidos con el 10\% y el 20\% de restricciones, aunque hay que destacar que la función objetivo es algo menor en el 20\% de restricciones en Zoo y Bupa, aunque en Glass aumenta muy poco.
Además, en este algoritmo no obtenemos tanta diferencia entre los tiempos de ejecución en el conjunto de datos Bupa. También cabe resaltar que el número de restricciones inclumplidas en Bupa, no aumenta tan drásticamente como ocurría antes.

\subsubsection{Algoritmo Memético (AM(10, 0.1mej))}


\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 0.1mej) en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 8 & 0.773446 & 0.834067 & 0.957 &				12 & 0.248656 & 0.260464 & 3.847 &			 	126 & 0.123256 & 0.157023 & 9.082		\\ \hline
	22 		& 9 & 0.584812 & 0.653011 & 0.975 &				39 & 0.210392 & 0.250738 & 3.858 &		 	179 & 0.126753 & 0.174723 & 9.127		\\ \hline
	100 	& 10 & 0.600063 & 0.67584 & 0.968 &				37 & 0.1962 & 0.23261 & 3.840 &				249 & 0.122729 & 0.189458 & 9.083		\\ \hline
	222 	& 11 & 0.624686 & 0.70804 & 0.990 &				48 & 0.185721 & 0.232955 & 3.869 & 			212 & 0.126298 & 0.183111 & 9.024		\\ \hline
	273687 	& 6 & 0.602718 & 0.648184 & 0.942 &				52 & 0.187526 & 0.238696 & 3.859 &			210 & 0.126964 & 0.183241 & 9.098		\\ \hline
	\textbf{Media} &  8.8 & 	0.6371450 & 	0.7038284 & 	0.9664000 & 	37.6 & 	0.2116120	 & 0.2447504	 & 3.8546000 & 	195.2 & 	0.1252000 & 	0.1775112 & 	9.0828000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}



\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados obtenidos por el algoritmo AM(10, 0.1mej) en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Semilla}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	7   	& 36 & 0.611821 & 0.804567 & 1.126 &				111 & 0.205401 & 0.263189 & 5.423 &			 	472 & 0.139079 & 0.204895 & 10.594		\\ \hline
	22 		& 14 & 0.733343 & 0.841299 & 1.135 &				39 & 0.244055 & 0.264359 & 5.451 &		 	236 & 0.138753 & 0.171661 & 10.622		\\ \hline
	100 	& 21 & 0.695684 & 0.766212 & 1.139 &				34 & 0.241753 & 0.259454 & 5.439 &				392 & 0.116866 & 0.171526 & 10.685		\\ \hline
	222 	& 10 & 0.70747 & 0.761229 & 1.135 &				 31 & 0.242694 & 0.258833 & 5.428 & 			245 & 0.123429 & 0.157592 & 10.878			\\ \hline
	273687 	& 19 & 0.712457 & 0.760553 & 1.147 &				36 & 0.246296 & 0.265038 & 5.464 &			225 & 0.121497 & 0.152871 & 10.782		\\ \hline
	\textbf{Media} & 20.0 & 	0.69206 & 	0.7867720 & 	1.1364000 & 	50.2 & 	0.2346206	 & 0.2603150	 & 5.4410000 & 	314.0	 & 0.1276882	 & 0.1761858 & 	10.7122000  \\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

En este caso aumenta un poco la desviación general en Zoo y Glass al pasar del 10\% de restricciones al 20\% de restricciones, aunque en Bupa se mantiene similar. Sin embargo, 
la función objetivo aumenta en Zoo y en Glass al pasar del 10\% al 20\% de restricciones, pero Bupa disminuye mínimamente.
Seguimos obteniendo menor diferencia entre el número de restricciones incumplidas, en especial en el conjunto de datos de Bupa.

\subsubsection{Resultados globales}


\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados globales en el PAR con 10\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Algoritmo}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	\textbf{COPKM}      & 7.4 & 0.9741962 & 1.0302698 & 0.0060		& 4.6 & 0.3786250 & 0.3831514 & 0.0378     & 41.6 & 0.2327392 & 0.2438876 & 0.3292  \\ \hline
	\textbf{BL}    & 15.0 & 0.5940342  & 0.7076986 & 0.5426 & 34.0 & 0.2194266 & 0.2528840 & 1.1332 			& 117.6 & 0.1130182 & 0.1747302 & 8.5574		\\ \hline
	\textbf{AGG-UN}    & 7.0 & 	0.6596420 & 	0.7633408 & 	0.9118 & 	69.6 & 	0.2440152 & 	0.3125044 & 	3.7074 & 	611.8 & 	0.1649540 & 	0.3300348 & 	9.3200		\\ \hline
	\textbf{AGG-SF}     & 13.2 & 	0.6359086 & 	0.7359334 & 	0.9668 & 	87.8 & 	0.2515632 & 	0.3379622 & 	3.8250 & 	653.0 & 	0.1688476 & 	0.3438436 & 	9.6328		\\ \hline
	\textbf{AGE-UN}    &  13.8 & 	0.6711520 & 	0.7799214 & 	0.9884 & 	61.2 & 	0.2425222 & 	0.3027456 & 	3.9146 & 	568.6 & 	0.1563684 & 	0.3087464 & 	9.5332		\\ \hline
	\textbf{AGE-SF}    & 8.0 & 	0.6825176 & 	0.7431386 & 	1.0646 & 	57.0 & 	0.2408452 & 	0.2969356 & 	4.0890 & 	550.6 & 	0.1608524 & 	0.3084064 & 	9.8626	\\ \hline
	\textbf{AM(10, 1.0)}    & 13.6 & 	0.6604906 & 	0.7635468 & 	0.9072 & 	124.8 & 	0.2552998 & 	0.3781082 & 	3.7808 & 	718.8 & 	0.2164966 & 	0.4091262 & 	14.7856 		\\ \hline
	\textbf{AM(10, 0.1)}    & 12.0 & 	0.7325420 & 	0.8234738 & 	0.9720 & 	42.8 & 	0.1989830 & 	0.2460200 & 	3.8352 & 	226.4 & 	0.1393972 & 	0.2000696 & 	9.2172		\\ \hline
	\textbf{AM(10, 0.1mej)}    & 8.8 & 	0.6371450 & 	0.7038284 & 	0.9664 & 	37.6 & 	0.2116120	 & 0.2447504	 & 3.8546 & 	195.2 & 	0.1252000 & 	0.1775112 & 	9.0828		\\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}	

\begin{table}[H]
	\tiny

	\begin{adjustwidth}{-1cm}{-1cm}%
	
	\begin{tabular}{|l|c|c|c|c|c|c|c|c|c|c|c|c|}
	\hline
	\multicolumn{13}{|c|}{\textbf{Resultados globales en el PAR con 20\% de restricciones}}                                                                                                                                                                                                                                                                                                                                            \\ \hline
	\multicolumn{1}{|c|}{\multirow{2}{*}{Algoritmo}} & \multicolumn{4}{c|}{Zoo}                                                                                          & \multicolumn{4}{c|}{Glass}                                                                                         & \multicolumn{4}{c|}{Bupa}                                                                                          \\ \cline{2-13} 
	\multicolumn{1}{|c|}{}                                  & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} & \multicolumn{1}{l|}{Infeasable} & \multicolumn{1}{l|}{DesvGen} & \multicolumn{1}{l|}{Agr.} & \multicolumn{1}{l|}{T} \\ \hline
	\textbf{COPKM}     & 1.8 & 0.9422462 &  0.9495146  & 0.0064      						 & 1.6 & 0.3451134 & 0.3459460 & 0.024     & 6.0 & 0.2367594 & 0.2380166 & 0.2098  \\ \hline
	\textbf{BL}   	   & 21.6 & 0.7011310 & 0.7883536 & 0.3854     							& 102.8 & 0.2148274 & 0.2683460 & 1.1226 & 215.2 & 0.1154614 & 0.1454694 & 9.2414 		\\ \hline
	\textbf{AGG-UN}    & 19.6 & 	0.7142966 & 	0.7934430 & 	0.9834 					& 	111.0 & 	0.2266004 & 	0.2804316 & 	4.7368 & 	1222.6	 & 0.1623380 & 	0.3328184 & 	13.1866		\\ \hline
	\textbf{AGG-SF}    &  27.2 & 	0.7384064 & 	0.8482426 & 	1.0364 					& 	93.2 & 	0.2401368 & 	0.2886574 & 	4.8370 & 	1216.8	 & 0.1615072 & 	0.3311792	 & 12.3902	\\ \hline
	\textbf{AGE-UN}    &  23.4 & 	0.6874510 & 	0.7819420 & 	1.0772 					& 	99.8 & 	0.2308080 & 	0.2852010 & 	4.9615	 & 1058.4 & 	0.1514614 & 	0.2990410 & 	12.4628	\\ \hline
	\textbf{AGE-SF}    &  19.2 & 	0.6997730	 & 0.7773042 & 	1.1354						 & 	64.4	 & 0.2441532 & 	0.2776804 & 	5.0594 & 	1079.6 & 	0.1525292 & 	0.3030696 & 	12.6932 		\\ \hline
	\textbf{AM(10, 1.0)}    & 12.8 & 	0.7215220 & 	0.7687846	 & 1.0786				 & 	97.6 & 	0.2256960 & 	0.2765100 & 	4.9602 & 	1365.6	 & 0.2024634 & 	0.3928842 & 	21.9550		\\ \hline
	\textbf{AM(10, 0.1)}    & 16.0 & 	0.7015560	 & 0.7678202	 & 1.1380				 & 83.8 & 	0.2203072 & 	0.2639340 & 	5.4392 & 	394.2	 & 0.1373086 & 	0.1902760 & 	12.4348		\\ \hline
	\textbf{AM(10, 0.1mej)}    & 20.0 & 	0.6920600 & 	0.7867720 & 	1.1364				 & 	50.2 & 	0.2346206	 & 0.2603150	 & 5.4410 & 	314.0	 & 0.1276882	 & 0.1761858 & 	10.7122		\\ \hline
	\end{tabular}
	
	\end{adjustwidth}
	
\end{table}

\subsection{Análisis de resultados}

En estas tablas podemos comparar los resultados obtenidos por todos los algoritmos implementados hasta el momento.

En cuanto al \textbf{número de restricciones incumplidas}, observamos que con el 10\% de las restricciones en el conjunto de datos Zoo se mantiene muy parecida, de hecho los mejores resultados los obtenemos con COPKM, AGG-UN, AGE-SF y AM(10, 0.1mej).
Con el 20\% de restricciones este número se mantiene muy  similar, salvo en el algoritmo Greedy que es mucho menor. También obtenemos mejores resultados de esta medida en COPKM, AGG-UN, AGE-SF, AM(10,1.0) y AM(10, 0.1).
En el conjunto de datos Glass con el 10\% de restricciones, observamos que esta medida varía algo más entre los distintos algoritmos empleados. El mejor resultado lo obtiene COPKM, seguido de BL, AM(10, 0.1mej) y AM(10, 0.1). El peor resultado lo obtiene AM(10, 1.0) con diferencia.
En cuanto al 20\% de las restricciones, el mejor resultado lo obtenemos con COPKM, seguido de AM(10, 0.1mej), seguido de AGE-SF y seguido de AM(10, 0.1). Sin embargo, el peor resultado lo obtenemos con AGG-UN.
Con respecto al conjunto de datos Bupa, con el 10\% de las restricciones obtenemos mejores resultados con COPKM, BL, AM(10, 0.1mej) y AM(10, 0.1). El peor resultado lo obtiene AM(10, 1.0).
Si consideramos el 20\% de las restricciones, el mejor resultado lo obtiene  COPKM, seguido de BL, seguido de AM(10, 0.1mej) y seguido de AM(10, 0.1). Sin embargo, el peor resultado lo obtiene AM(10, 1.0).
En resumen, en los tres conjuntos de datos, considerando el 10\% y el 20\% de las restricciones, COPKM obtiene menor número de restricciones incumplidas. Aunque los algoritmos meméticos AM(10, 0.1) y AM(10, 0.1mej) también obtienen pocas restricciones incumplidas en comparación con el resto de los algoritmos empleados.

En cuanto a la \textbf{desviación general}, observamos que Greedy obtiene peores resultados en todos los conjuntos de datos considerados. Los mejores resultados los obtienen Bupa  y los algoritmos meméticos AM(10, 0.1) y AM(10, 0.1mej).
Estos dos últimos algoritmos obtienen una desviación general muy similar a BL, a veces es un poco mayor y otras veces incluso consiguen obtener resultados más bajos, aunque siguen manteniéndose muy similares. Sin embargo, los algoritmos genéticos obtienen unos resultados muy similares al aplicarlos
entre los mismos conjuntos de datos, apenas hay diferencia.

Cabe destacar el \textbf{tiempo} (medido en segundos) empleado por cada algoritmo en los distintos conjuntos de datos. En esta práctica se ha notado cómo ha aumentado esta medida al implementar los algoritmos genéticos y meméticos. Hemos pasado de apenas tardar de ejecutar cada algoritmo de apenas medio segundo, a tardar casi 22 segundos en el peor de los casos.
En el conjunto de datos Zoo apenas se nota el cambio, pues apenas tarda 1 segundo. En Glass notamos un pequeño aumento, pues cada algoritmo tarda en ejecutarse unos 4 segundos. Sin embargo, en Bupa observamos que, dependiendo del algoritmo empleado, podemos obtener tiempos de ejecución que varían entre los 8 segundos y los 21 segundos.
Esto tiene sentido, pues en Greedy y en BL solo trabajabamos con un vector solución, en esta práctica hemos trabajado con un conjunto de vectores solución, en concreto 50, por lo que el número de operaciones que realizamos aumenta considerablemente. De hecho, en Bupa observamos mayor diferencia pues este conjunto de datos tiene mayor número de instancias.

Con respecto al \textbf{agregado}, es decir, la función objetivo que queremos minimizar, también obtenemos unos resultados bastante coherentes. Esto es, en el conjunto de datos Zoo obtenemos que Greedy obtiene el peor resultado. Los algoritmos genéticos obtienen buenos resultados, aunque en el caso del 10\% de las restricciones, 
son un poco peores que los obtenidos por BL; si consideramos el 20\% de las restricciones, los resultados son más similares incluso con AGE obtenemos mejores resultados que con BL, aunque apenas se nota la diferencia. Si comparamos la BL con los algoritmos meméticos, en el 10\% de las restricciones AM(10, 1.0) y AM(10, 0.1) obtienen unos resultados mayores que los de la BL,
pero AM(10, 0.1mej) consigue obtener minimizar la función objetivo, obteniendo el  mejor resultado. En cuanto al 20\% de las restricciones, los algoritmos meméticos obtienen resultados mucho mejores que la BL, pues la función objetivo resultante es menor.
En cuanto al conjunto de datos Glass, con el 10\% de las restricciones, BL consigue obtener mejor resultado que los algoritmos genéticos, pero los algoritmos meméticos AM(10, 0.1) y AM(10, 0.1mej) consiguen minimizar más todavía esta función. Lo mismo ocurre si consideramos el 20\% de las restricciones.
En cuanto al conjunto de datos Bupa, obtenemos mejores resultados con BL aunque los algoritmos meméticos AM(10, 0.1) y AM(10, 0.1mej) obtienen resultados muy similares. Los algoritmos genéticos siguen obtienendo resultados peores. Hay que destacar también que AM(10, 1.0) obtiene unos resultados bastante altos, pues al tener tantas instancias y al considerar toda la población para aplicarle la BLS,
se llega al máximo del número de las evaluaciones de la función objetivo mucho antes, por lo que no le da tiempo a minimizar esta función.

En resumen, los algoritmos genéticos obtienen unos resultados un poco peores a los obtenidos por la búsqueda local. Sin embargo, los algoritmos meméticos, salvo el AM(10, 1.0), obtienen unos resultados similares e incluso en algunos casos mejores que la búsqueda local.
Esto se debe a que la población con la que trabajamos tiene mucha mayor diversidad y ayuda a que no se estanquen en mínimos locales. 
El algoritmo AM(10, 1.0) no obtiene tan buenos resultados como los otros meméticos, pues aplica la BLS a todos los cromosomas de la población,
esto hace que converja mucho más rápido, sobre todo cuando el conjunto de datos tiene mayor número de instancias.
También encontramos una diferencia entre los algoritmos genéticos considerados, pues los generacionales obtienen, en general, peores resultados que los estacionarios. Esto se debe a que la exploración de los algoritmos estacionarios es mucho mayor y encuentra soluciones con más diversidad.


\newpage

\section{Referencias bibliográficas u otro tipo de material consultado}

\begin{itemize}
	\item Material proporcionado por los profesores sobre la asignatura.
	
		\url{https://sci2s.ugr.es/node/124}
	\item Material consultado para medir tiempos.
	
		\url{https://www.geeksforgeeks.org/measure-execution-time-function-cpp/}
\end{itemize}